# -*- coding: utf-8 -*-
"""Analises imuno peptideos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MxhNtLumdlN_OrM42iqLK_dWXIt5T42h

Segui fluxo abaixo primeiro gerando dados e depois graficos: Iniciando com # --- BLOCO 1: SETUP DE INFRAESTRUTURA ---
"""

# --- BLOCO 1: SETUP DE INFRAESTRUTURA ---
import os

# Instala√ß√£o silenciosa das depend√™ncias
print("Instalando depend√™ncias... aguarde.")
!pip install -q biopython mhcflurry openpyxl

# O comando cr√≠tico que estava faltando ou falhando.
# For√ßamos o download espec√≠fico dos modelos de apresenta√ß√£o classe 1.
print("Baixando modelos do MHCflurry (isso pode levar 1-2 minutos)...")
!mhcflurry-downloads fetch models_class1_presentation

print("‚úÖ Ambiente configurado com sucesso.")

"""**# --- BLOCO 2 FINAL (FIX KEYERROR) ---** aqui pede um arquivo tsv com lista de peptideos entao deixa sua lista em formato de tabela: peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo peptideo **sem cabe√ßalho** salva do excel para formato texto (separado por tabula√ß√µes) .tsv ou bloco de notas e depois salva .tsv selecionando em arquivo>salvar como todos os formatos artuivo.tsv.

MHCflurry n√£o √© o melhor mas √© o que tem API ent√£o usa ele inicialmente e vai acelerando a analise preliminarmente se der ruim nele √© euim nos outros tbm, apos carregar vai pedir para salvar ai vc salva no seu pc os dados brutos agora em .xls, vamos usar esse .xls para proximas analises
"""

# --- BLOCO 2 FINAL (FIX KEYERROR) ---
import pandas as pd
import re
import io
import numpy as np
from Bio.SeqUtils.ProtParam import ProteinAnalysis
from mhcflurry import Class1PresentationPredictor
from google.colab import files

def load_user_data():
    """L√™ arquivos e lineariza (sem altera√ß√µes aqui)."""
    print("\n--- FA√áA UPLOAD DO SEU ARQUIVO TSV ---")
    uploaded = files.upload()
    if not uploaded: raise ValueError("Nenhum arquivo enviado.")
    filename = next(iter(uploaded))
    try:
        df_raw = pd.read_csv(io.BytesIO(uploaded[filename]), sep='\t', header=None)
        peptides_flat = df_raw.values.flatten()
        df_clean = pd.DataFrame(peptides_flat, columns=['peptide'])
        df_clean = df_clean.dropna()
        df_clean['peptide'] = df_clean['peptide'].astype(str).str.strip()
        df_clean = df_clean[df_clean['peptide'] != '']
        print(f"Dados carregados: {len(df_clean)} pept√≠deos brutos.")
        return df_clean, filename
    except Exception as e:
        print(f"‚ùå Erro ao processar arquivo: {e}")
        return None, None

def validate_peptides(df):
    """Limpeza e filtro de tamanho biol√≥gico."""
    aa_regex = re.compile("^[ACDEFGHIKLMNPQRSTVWY]+$")
    df['peptide'] = df['peptide'].str.upper()
    df["valid"] = df['peptide'].apply(lambda x: bool(aa_regex.match(x)))

    # Remove duplicatas e inv√°lidos
    df_valid = df[df["valid"]].drop(columns=["valid"]).drop_duplicates(subset=['peptide']).copy()

    # Filtro essencial: MHC-I liga em 8-14 meros
    df_valid = df_valid[df_valid['peptide'].str.len().between(8, 14)]

    return df_valid

def get_physchem_properties(peptide):
    try:
        pa = ProteinAnalysis(peptide)
        return {
            "length": len(peptide),
            "mw": round(pa.molecular_weight(), 2),
            "pI": round(pa.isoelectric_point(), 2),
            "gravy": round(pa.gravy(), 3)
        }
    except:
        return {}

def run_pipeline(df, alleles):
    # 1. Propriedades F√≠sico-qu√≠micas
    print("Calculando propriedades f√≠sico-qu√≠micas...")
    props = df['peptide'].apply(get_physchem_properties).apply(pd.Series)
    df = pd.concat([df.reset_index(drop=True), props.reset_index(drop=True)], axis=1)

    # 2. MHCflurry (Com verifica√ß√£o de colunas)
    print(f"Rodando predi√ß√£o MHCflurry para {alleles}...")
    predictor = Class1PresentationPredictor.load()

    # Predi√ß√£o em modo Gen√≥tipo
    results = predictor.predict(
        peptides=df['peptide'].values,
        alleles=alleles,
        include_affinity_percentile=True,
        verbose=0
    )

    # --- DEBUG AUTOM√ÅTICO ---
    # Isso impede o erro. Se o nome mudar, o c√≥digo se adapta.
    cols = results.columns
    # print(f"DEBUG: Colunas retornadas pelo MHCflurry: {cols}")

    # Mapeamento seguro de colunas
    df['mhc_score'] = results['presentation_score']

    # Tenta pegar afinidade (pode variar o nome)
    if 'affinity' in cols:
        df['affinity_nm'] = results['affinity']
    else:
        df['affinity_nm'] = np.nan # Preenche com vazio se n√£o vier

    # Tenta pegar o rank de percentil (A causa do erro anterior)
    if 'presentation_percentile' in cols:
        df['percentile_rank'] = results['presentation_percentile']
    elif 'best_allele_percentile' in cols:
        df['percentile_rank'] = results['best_allele_percentile']
    else:
        # Se n√£o tiver percentil, criamos um rank baseado no score bruto
        print("‚ö†Ô∏è Aviso: Percentil n√£o retornado, calculando rank relativo interno.")
        df['percentile_rank'] = df['mhc_score'].rank(pct=True, ascending=False)

    # 3. Score Final Normalizado
    min_score = df['mhc_score'].min()
    max_score = df['mhc_score'].max()

    if max_score != min_score:
        df['norm_mhc'] = (df['mhc_score'] - min_score) / (max_score - min_score)
    else:
        df['norm_mhc'] = 0

    # Quanto maior o score de apresenta√ß√£o, melhor.
    df['final_rank_score'] = df['norm_mhc']

    # Retorna ordenado. Importante: Para 'percentile_rank', MENOR √© melhor.
    # Para 'final_rank_score' (nosso c√°lculo), MAIOR √© melhor.
    return df.sort_values(by='final_rank_score', ascending=False)
    # --- BLOCO 3: EXECU√á√ÉO ---

# Defina o alelo (HLA). Se n√£o souber, use o A*02:01 que √© o mais comum em caucasianos.
ALLELES = ["HLA-A*02:01"]

# 1. Carregar e Processar
df_input, filename = load_user_data()

if df_input is not None and not df_input.empty:
    # 2. Validar
    df_clean = validate_peptides(df_input)

    if not df_clean.empty:
        # 3. Rodar Pipeline Inteligente
        df_result = run_pipeline(df_clean, ALLELES)

        # 4. Exportar para Excel
        output_name = f"RESULTADO_FINAL_{filename.split('.')[0]}.xlsx"
        print(f"\nüíæ Salvando relat√≥rio completo (era .tsv mas vai virar .xls) em: {output_name}...")

        df_result.to_excel(output_name, index=False)
        files.download(output_name)

        print("\nüèÜ TOP 5 CANDIDATOS (Melhores ligantes):")
        # Mostra colunas relevantes: Pept√≠deo, Afinidade (nM) e Rank %
        print(df_result[['peptide', 'affinity_nm', 'percentile_rank', 'gravy']].head().to_string(index=False))
    else:
        print("‚ùå Todos os pept√≠deos eram inv√°lidos ap√≥s a limpeza.")
else:
    print("‚ùå Falha no carregamento dos dados.")

pegue o arquivo .xls gerado anteriormente e adicione na proxima analise, o bloco de codgo √© LONGO MESMO mas evita bugs nessa parte sendo assim.

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import io
from google.colab import files
from collections import Counter

def generate_dashboard():
    # --- 1. SOLICITA√á√ÉO DO ARQUIVO ---
    print("\nüìä --- UPLOAD DO ARQUIVO PARA DASHBOARD ---")
    print("Por favor, envie o arquivo Excel (.xlsx) ou CSV que voc√™ revisou.")
    uploaded = files.upload()

    if not uploaded:
        print("‚ùå Nenhum arquivo enviado.")
        return

    filename = next(iter(uploaded))

    # --- 2. CARREGAMENTO INTELIGENTE ---
    try:
        if filename.endswith('.xlsx'):
            df = pd.read_excel(io.BytesIO(uploaded[filename]))
        else:
            # Tenta ler CSV com separadores comuns
            try:
                df = pd.read_csv(io.BytesIO(uploaded[filename]), sep=',')
            except:
                df = pd.read_csv(io.BytesIO(uploaded[filename]), sep='\t')

        # Limpeza de nomes de colunas (remove espa√ßos extras)
        df.columns = [c.strip() for c in df.columns]
        print(f"‚úÖ Arquivo '{filename}' carregado com sucesso. ({len(df)} registros)")

    except Exception as e:
        print(f"‚ùå Erro ao ler o arquivo: {e}")
        return

    # --- 3. CONFIGURA√á√ÉO VISUAL ---
    sns.set_theme(style="whitegrid", context="talk") # Estilo limpo para publica√ß√£o
    fig = plt.figure(figsize=(22, 14), constrained_layout=True)
    gs = fig.add_gridspec(2, 3)

    # Definir subplots
    ax1 = fig.add_subplot(gs[0, 0]) # Afinidade
    ax2 = fig.add_subplot(gs[0, 1]) # Espa√ßo Qu√≠mico
    ax3 = fig.add_subplot(gs[0, 2]) # Tamanho
    ax4 = fig.add_subplot(gs[1, :]) # Enriquecimento (Barra larga)

    # --- GR√ÅFICO 1: DISTRIBUI√á√ÉO DE AFINIDADE (O Funil de Sele√ß√£o) ---
    # Verifica qual coluna de score usar
    if 'affinity_nm' in df.columns:
        # Filtra valores extremos para n√£o quebrar o gr√°fico (log scale)
        plot_data = df[df['affinity_nm'] > 0]
        sns.histplot(data=plot_data, x='affinity_nm', log_scale=True, kde=True, color="#2E86C1", ax=ax1)
        # Linhas de corte biol√≥gico
        ax1.axvline(50, color='#E74C3C', linestyle='--', linewidth=2, label='Forte (<50nM)')
        ax1.axvline(500, color='#F1C40F', linestyle='--', linewidth=2, label='Fraco (<500nM)')
        ax1.set_title("Qualidade da Liga√ß√£o (IC50)")
        ax1.set_xlabel("Afinidade (nM) - Escala Log")
        ax1.legend(fontsize='small', loc='upper right')
    elif 'mhc_score' in df.columns:
        sns.histplot(data=df, x='mhc_score', kde=True, color="#8E44AD", ax=ax1)
        ax1.set_title("Distribui√ß√£o do Score de Apresenta√ß√£o")
    else:
        ax1.text(0.5, 0.5, "Coluna de Afinidade/Score n√£o encontrada", ha='center')

    # --- GR√ÅFICO 2: MAPA F√çSICO-QU√çMICO (Hydrophobicity vs pI) ---
    if 'gravy' in df.columns and 'pI' in df.columns:
        # Usa o rank final para colorir, se existir
        color_col = 'final_rank_score' if 'final_rank_score' in df.columns else None

        scatter = ax2.scatter(
            df['pI'],
            df['gravy'],
            c=df[color_col] if color_col else 'gray',
            cmap='viridis',
            alpha=0.6,
            s=80,
            edgecolor='white'
        )
        if color_col:
            plt.colorbar(scatter, ax=ax2, label='Score Final (Melhor = Amarelo)')

        ax2.set_title("Perfil F√≠sico-Qu√≠mico")
        ax2.set_xlabel("Ponto Isoel√©trico (pI)")
        ax2.set_ylabel("Hidrofobicidade (GRAVY)")
        ax2.axvline(7.4, color='gray', linestyle=':', label='pH Sangue')
        ax2.axhline(0, color='gray', linestyle=':', label='Neutro')
    else:
        ax2.text(0.5, 0.5, "Dados de pI/GRAVY ausentes", ha='center')

    # --- GR√ÅFICO 3: PREFER√äNCIA DE TAMANHO ---
    if 'length' in df.columns:
        # Define Top 10% (ou top 50 se for dataset pequeno)
        n_top = max(10, int(len(df) * 0.1))
        # Ordena pelo melhor crit√©rio dispon√≠vel
        sort_col = 'final_rank_score' if 'final_rank_score' in df.columns else df.columns[0]
        top_df = df.nlargest(n_top, sort_col)

        counts_total = df['length'].value_counts().sort_index()
        counts_top = top_df['length'].value_counts().sort_index()

        ax3.bar(counts_total.index, counts_total.values, alpha=0.3, color='gray', label='Popula√ß√£o Total')
        ax3.bar(counts_top.index, counts_top.values, alpha=0.9, color='#2ECC71', label=f'Top {n_top} Melhores')
        ax3.set_title(f"Vi√©s de Tamanho (Top {n_top} vs Total)")
        ax3.set_xlabel("Comprimento do Pept√≠deo")
        ax3.legend()

    # --- GR√ÅFICO 4: AN√ÅLISE DE MOTIF (Quais amino√°cidos dominam?) ---
    if 'peptide' in df.columns:
        # Analisa Top 10% vs Total
        all_seqs = "".join(df['peptide'].astype(str).tolist())
        top_seqs = "".join(top_df['peptide'].astype(str).tolist())

        total_counts = Counter(all_seqs)
        top_counts = Counter(top_seqs)

        aas = sorted("ACDEFGHIKLMNPQRSTVWY")
        log_fc = []

        for aa in aas:
            f_total = total_counts.get(aa, 0) / len(all_seqs) if len(all_seqs) > 0 else 1
            f_top = top_counts.get(aa, 0) / len(top_seqs) if len(top_seqs) > 0 else 1
            # Log2 Fold Change
            val = np.log2(f_top / f_total) if f_total > 0 and f_top > 0 else 0
            log_fc.append(val)

        colors = ['#E74C3C' if x < 0 else '#27AE60' for x in log_fc]
        ax4.bar(aas, log_fc, color=colors)
        ax4.axhline(0, color='black', linewidth=1)
        ax4.set_title("Quais amino√°cidos s√£o favorecidos nos melhores ligantes? (Log2 Fold Change)")
        ax4.set_ylabel("Depletado <---> Enriquecido")
        ax4.set_xticks(range(len(aas)))
        ax4.set_xticklabels(aas)

    # Salvar e Mostrar
    plt.savefig("Dashboard_Analise_Peptideos.png", dpi=300, bbox_inches='tight')
    print("\nüíæ Imagem salva como 'Dashboard_Analise_Peptideos.png'")
    plt.show()

# Executa a fun√ß√£o
generate_dashboard()
# --- INSTALA√á√ÉO DE FERRAMENTAS ESPEC√çFICAS ---
try:
    import logomaker
    import Levenshtein
except ImportError:
    print("Instalando bibliotecas de visualiza√ß√£o avan√ßada...")
    !pip install -q logomaker python-Levenshtein

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist

# --- FUN√á√ÉO DE AN√ÅLISE DE MOTIF E DIVERSIDADE ---
def advanced_immuno_plots(df):
    # Filtrar apenas os top candidatos (ex: Top 1% ou Top 50 hits)
    # Focamos nos 9-meros pois s√£o o padr√£o ouro para HLA-A*02
    top_peptides = df[df['length'] == 9].sort_values('final_rank_score', ascending=False).head(100)

    if len(top_peptides) < 5:
        print("‚ùå Poucos pept√≠deos de 9 amino√°cidos para gerar Motif. Tente um dataset maior.")
        return

    # Configura√ß√£o da Figura
    fig = plt.figure(figsize=(20, 12), constrained_layout=True)
    gs = fig.add_gridspec(2, 2)

    # --- 1. SEQUENCE LOGO (A Assinatura do Alvo) ---
    # Mostra a conserva√ß√£o posicional. Immunologistas procuram as "√¢ncoras" nas posi√ß√µes 2 e 9.
    ax1 = fig.add_subplot(gs[0, :]) # Ocupa o topo todo

    # Cria matriz de frequ√™ncia
    seq_list = top_peptides['peptide'].tolist()
    counts_mat = logomaker.alignment_to_matrix(seq_list)

    # Gera o Logo
    logo = logomaker.Logo(counts_mat, ax=ax1, color_scheme='skylign_protein')
    ax1.set_title("Consenso do Motif de Liga√ß√£o (Top 100 Candidatos)", fontsize=16)
    ax1.set_ylabel("Frequ√™ncia (Bits)")
    ax1.set_xlabel("Posi√ß√£o no Pept√≠deo (1-9)")
    ax1.set_xticks(range(0, 9))
    ax1.set_xticklabels(range(1, 10))

    # Destacar as √Çncoras T√≠picas do HLA-A*02 (Pos 2 e 9)
    ax1.axvline(1, color='red', linestyle='--', alpha=0.5) # Posi√ß√£o 2 (Python index 1)
    ax1.axvline(8, color='red', linestyle='--', alpha=0.5) # Posi√ß√£o 9 (Python index 8)
    ax1.text(1.1, ax1.get_ylim()[1]*0.8, '√Çncora P2', color='red')
    ax1.text(8.1, ax1.get_ylim()[1]*0.8, '√Çncora P9', color='red')

    # --- 2. CLUSTERIZA√á√ÉO DE SEQU√äNCIAS (Heatmap de Similaridade) ---
    # Evita redund√¢ncia. Se o mapa for todo vermelho escuro, seus pept√≠deos s√£o iguais.
    # Se for xadrez, voc√™ tem diversidade viral.
    ax2 = fig.add_subplot(gs[1, 0])

    # Pegamos os top 20 para o heatmap ficar leg√≠vel
    top_20 = top_peptides.head(20)['peptide'].tolist()
    sim_matrix = np.zeros((20, 20))

    for i in range(20):
        for j in range(20):
            # Dist√¢ncia de Levenshtein (quanto menor, mais parecidos)
            sim_matrix[i, j] = lev_dist(top_20[i], top_20[j])

    sns.heatmap(sim_matrix, ax=ax2, cmap="Blues_r", annot=True, fmt=".0f",
                xticklabels=top_20, yticklabels=top_20, cbar_kws={'label': 'Dist√¢ncia de Edi√ß√£o (Muta√ß√µes)'})
    ax2.set_title("Redund√¢ncia de Ep√≠topos (Top 20)", fontsize=14)
    ax2.tick_params(axis='both', which='major', labelsize=8)

    # --- 3. SCORE DE IMUNOGENICIDADE (Proxy) ---
    # Posi√ß√µes 4, 5, 6 s√£o as que o TCR (Linf√≥cito T) "v√™".
    # Res√≠duos grandes e arom√°ticos aqui aumentam a chance de resposta imune.
    ax3 = fig.add_subplot(gs[0.5, 0.5])

    # C√°lculo simplificado de "potencial TCR" (Peso em posi√ß√µes centrais)
    # Baseado em Calis et al. (TCR contact residues)
    def simple_immuno_score(pep):
        # Amino√°cidos hidrof√≥bicos grandes/arom√°ticos no meio aumentam imunogenicidade
        tcr_contact = pep[3:6] # Posi√ß√µes 4, 5, 6
        score = 0
        weights = {'W': 1.0, 'F': 0.9, 'Y': 0.8, 'I': 0.5, 'L': 0.5, 'V': 0.4}
        for aa in tcr_contact:
            score += weights.get(aa, 0.1)
        return score

    top_peptides = top_peptides.copy() # Evita warning
    top_peptides['tcr_score'] = top_peptides['peptide'].apply(simple_immuno_score)

    # Scatter plot: Afinidade (Eixo X) vs "Visibilidade TCR" (Eixo Y)
    sns.scatterplot(data=top_peptides, x='affinity_nm', y='tcr_score',
                    hue='final_rank_score', size='hydrophobicity', sizes=(50, 200),
                    palette='viridis', ax=ax3, legend=False)

    # Inverter eixo X (menor afinidade √© melhor)
    ax3.set_xscale('log')
    ax3.invert_xaxis()

    ax3.set_title("O Quadrante M√°gico: Alta Afinidade + Alta Visibilidade", fontsize=10)
    ax3.set_xlabel("Afinidade MHC (nM) - Melhor p/ esquerda")
    ax3.set_ylabel("Potencial de Contato TCR (Score Estimado)")

    # Destacar os campe√µes
    best_cands = top_peptides[(top_peptides['affinity_nm'] < 50) & (top_peptides['tcr_score'] > 1.5)]
    for _, row in best_cands.head(5).iterrows():
        ax3.text(row['affinity_nm'], row['tcr_score'], row['peptide'], fontsize=9, ha='right')

    plt.show()

# --- EXECU√á√ÉO ---
# Assume que 'df' ou 'df_result' j√° existe na mem√≥ria.
# Se voc√™ acabou de reiniciar, descomente as linhas abaixo para recarregar o arquivo:
# from google.colab import files
# import io
# uploaded = files.upload()
# fname = next(iter(uploaded))
# df_result = pd.read_excel(io.BytesIO(uploaded[fname])) if fname.endswith('xlsx') else pd.read_csv(io.BytesIO(uploaded[fname]))

try:
    if 'df_result' in locals():
        advanced_immuno_plots(df_result)
    else:
        print("‚ö†Ô∏è Vari√°vel 'df_result' n√£o encontrada. Rode o bloco anterior ou carregue os dados.")
except Exception as e:
    print(f"Erro: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist

def plot_virology_story(df):
    # 1. Prepara√ß√£o dos Dados (Foco nos 9-meros, padr√£o HLA-A*02)
    # Filtramos apenas os pept√≠deos de tamanho 9 para alinhar o motif
    top_peptides = df[df['length'] == 9].sort_values('final_rank_score', ascending=False).head(100).copy()

    if len(top_peptides) < 10:
        print("‚ö†Ô∏è Aten√ß√£o: Menos de 10 pept√≠deos de 9-meros encontrados. O Sequence Logo pode ficar pobre.")

    # 2. Configura√ß√£o do Canvas
    fig = plt.figure(figsize=(22, 14), constrained_layout=True)
    gs = fig.add_gridspec(2, 2, height_ratios=[1, 1.2]) # Logo em cima, analises embaixo

    # --- GR√ÅFICO 1: SEQUENCE LOGO (A Assinatura do Alvo) ---
    ax1 = fig.add_subplot(gs[0, :])

    # Gera matriz de informa√ß√£o (Bits) em vez de probabilidade bruta
    # Isso destaca o que √© IMPORTANTE (Conservado) e diminui o ru√≠do
    seq_list = top_peptides['peptide'].tolist()
    counts_mat = logomaker.alignment_to_matrix(seq_list)
    # Transformamos em bits (Information Content) para limpar o gr√°fico
    info_mat = logomaker.transform_matrix(counts_mat, from_type='counts', to_type='information')

    logo = logomaker.Logo(info_mat, ax=ax1, color_scheme='chemistry') # 'chemistry' agrupa por propriedade (ex: hidrof√≥bicos = preto/azul)

    ax1.set_title("Impress√£o Digital do Ep√≠topo (Consenso dos Top 100)", fontsize=18)
    ax1.set_ylabel("Bits de Informa√ß√£o (Conserva√ß√£o)", fontsize=14)
    ax1.set_xlabel("Posi√ß√£o do Amino√°cido (Pept√≠deo 9-mer)", fontsize=14)
    ax1.set_xticks(range(0, 9))
    ax1.set_xticklabels([f"P{i}" for i in range(1, 10)])

    # Marcadores de √Çncora (Biologia do MHC)
    # Para HLA-A*02, esperamos P2 e P9/PŒ© altas.
    ax1.axvline(1, color='red', linestyle='--', alpha=0.6, linewidth=2)
    ax1.axvline(8, color='red', linestyle='--', alpha=0.6, linewidth=2)
    ax1.text(1.1, ax1.get_ylim()[1]*0.9, '√Çncora P2\n(Estabilidade)', color='#C0392B', fontweight='bold')
    ax1.text(8.1, ax1.get_ylim()[1]*0.9, '√Çncora P9\n(Travamento)', color='#C0392B', fontweight='bold')

    # --- GR√ÅFICO 2: DIVERSIDADE (Heatmap de Redund√¢ncia) ---
    ax2 = fig.add_subplot(gs[1, 0])

    # Top 15 para legibilidade
    n_sample = 15
    sample_peps = top_peptides.head(n_sample)['peptide'].tolist()
    sim_matrix = np.zeros((n_sample, n_sample))

    for i in range(n_sample):
        for j in range(n_sample):
            sim_matrix[i, j] = lev_dist(sample_peps[i], sample_peps[j])

    sns.heatmap(sim_matrix, ax=ax2, cmap="bone_r", annot=True, fmt=".0f",
                cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'}, square=True)

    ax2.set_title(f"Matriz de Redund√¢ncia (Top {n_sample})", fontsize=16)
    # Remove ticks para limpar se for apenas visual, ou rotaciona se quiser ler
    ax2.set_xticks([])
    ax2.set_yticks([])
    ax2.set_ylabel("Pept√≠deos (Ordenados por Rank)")

    # --- GR√ÅFICO 3: O "QUADRANTE M√ÅGICO" (Scatter Plot) ---
    ax3 = fig.add_subplot(gs[1, 1])

    # Recalcula o score TCR simples
    def simple_tcr_score(pep):
        # Pesos para amino√°cidos volumosos/arom√°ticos nas posi√ß√µes centrais (P4-P6)
        # Fonte: Calis et al (Immunogenicity prediction)
        mid_seq = pep[3:6]
        score = 0
        weights = {'W': 1.0, 'F': 0.8, 'Y': 0.8, 'I': 0.6, 'L': 0.5}
        for aa in mid_seq:
            score += weights.get(aa, 0.1)
        return score

    top_peptides['tcr_potential'] = top_peptides['peptide'].apply(simple_tcr_score)

    # Scatter Plot CORRIGIDO
    # size agora usa 'mw' (Molecular Weight) para representar tamanho f√≠sico
    # hue usa 'gravy' para mostrar hidrofobicidade
    scatter = sns.scatterplot(
        data=top_peptides,
        x='affinity_nm',
        y='tcr_potential',
        hue='gravy',           # Cor = Hidrofobicidade
        size='mw',             # Tamanho da bolinha = Peso Molecular
        sizes=(50, 300),
        palette='viridis',
        alpha=0.8,
        ax=ax3
    )

    # Eixo X em Log e Invertido (Menor afinidade √© melhor, ent√£o queremos < 50 na direita ou esquerda?)
    # Padr√£o visual: "Melhor para cima e para a direita".
    # Ent√£o vamos INVERTER o eixo X para que 10nM fique na direita.
    ax3.set_xscale('log')
    ax3.invert_xaxis()

    # Linhas de Corte
    ax3.axvline(50, color='red', linestyle=':', label='Limite Forte (50nM)')
    ax3.axhline(top_peptides['tcr_potential'].median(), color='gray', linestyle='--', label='Mediana TCR')

    ax3.set_title("Sele√ß√£o de Candidatos: Afinidade vs. Visibilidade", fontsize=16)
    ax3.set_xlabel("Afinidade Predita (nM) [Escala Log Invertida]", fontsize=12)
    ax3.set_ylabel("Potencial de Intera√ß√£o TCR (P4-P6)", fontsize=12)
    ax3.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0)

    # Anotar os Top 3 Campe√µes
    top_3 = top_peptides.head(3)
    for line in range(0, top_3.shape[0]):
        row = top_3.iloc[line]
        ax3.text(row['affinity_nm'], row['tcr_potential']+0.05,
                 row['peptide'], horizontalalignment='center',
                 fontweight='bold', color='black')

    plt.savefig("Painel_Virologia_Imunologia.png", dpi=300)
    plt.show()

# Executa
try:
    plot_virology_story(df_result)
except NameError:
    print("‚ùå Erro: 'df_result' n√£o encontrado. Carregue os dados primeiro.")
except Exception as e:
    print(f"‚ùå Erro desconhecido: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler

# --- CONFIGURA√á√ÉO EST√âTICA PROFISSIONAL ---
PALETTE = {
    'primary': '#2E86C1',   # Azul Profundo
    'success': '#27AE60',   # Verde Esmeralda
    'danger': '#C0392B',    # Vermelho Tijolo
    'highlight': '#F39C12', # Laranja
    'neutral': '#95A5A6',   # Cinza Concreto
    'dark': '#2C3E50'       # Azul Meia-noite
}
sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['axes.spines.top'] = False
plt.rcParams['axes.spines.right'] = False

def normalize_for_radar(df):
    """Normaliza colunas para escala 0-1 para o Radar Chart."""
    scaler = MinMaxScaler()
    df_norm = df.copy()

    # Inverter afinidade (menor valor = melhor)
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)

    # Lista de colunas para o Radar
    cols_to_norm = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']

    # Garante que todas existem e preenche ausentes
    for c in cols_to_norm:
        if c not in df_norm.columns: df_norm[c] = 0.5

    df_norm[cols_to_norm] = scaler.fit_transform(df_norm[cols_to_norm])
    return df_norm

def plot_master_dashboard(df):
    print("--- PROCESSANDO DADOS E GERANDO LAYOUT ---")

    # 1. C√ÅLCULO GLOBAL DE M√âTRICAS
    # Garante que tcr_potential exista
    if 'tcr_potential' not in df.columns:
        def simple_tcr(p):
            weights = {'W':1.0, 'F':0.8, 'Y':0.8, 'I':0.6, 'L':0.5}
            return sum([weights.get(aa, 0.1) for aa in str(p)[3:6]])
        df['tcr_potential'] = df['peptide'].apply(simple_tcr)

    # Ordena√ß√£o
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)

    # 2. DEFINI√á√ÉO DOS GRUPOS
    TOP_100 = df.head(100).copy()
    TOP_20  = df.head(20).copy()
    TOP_5   = df.head(5).copy()

    # Amostragem de fundo segura
    if len(df) > 100:
        background = df.iloc[100:].sample(min(len(df)-100, 1000))
    else:
        background = df.copy()

    # 3. LAYOUT DO DASHBOARD (Poster Size: 24x32)
    fig = plt.figure(figsize=(24, 32), constrained_layout=True)
    gs = fig.add_gridspec(4, 2, height_ratios=[0.8, 1, 1.2, 1])

    # --- LINHA 1: SEQUENCE LOGO (CORRE√á√ÉO APLICADA AQUI) ---
    ax_logo = fig.add_subplot(gs[0, :])

    seq_list = TOP_100['peptide'].astype(str).tolist()

    # --- CORRE√á√ÉO DO BUG FLOAT/INT ---
    # Pegamos a moda (tamanho mais comum) e FOR√áAMOS ser inteiro (int)
    try:
        common_len = int(df['length'].mode()[0])
    except:
        common_len = 9 # Fallback padr√£o se der erro na moda

    # Filtra apenas pept√≠deos desse tamanho para alinhar
    seq_list = [s for s in seq_list if len(s) == common_len]

    if len(seq_list) > 0:
        matrix = logomaker.alignment_to_matrix(seq_list)
        info_mat = logomaker.transform_matrix(matrix, from_type='counts', to_type='information')
        logo = logomaker.Logo(info_mat, ax=ax_logo, color_scheme='skylign_protein')

        ax_logo.set_title(f"1. Impress√£o Digital do Alvo (Consenso Top 100 - {common_len}mers)", fontsize=22, fontweight='bold', color=PALETTE['dark'], loc='left')
        ax_logo.set_ylabel("Bits (Conserva√ß√£o)", fontsize=16)

        # Agora range() recebe um inteiro garantido
        ax_logo.set_xticks(range(common_len))
        ax_logo.set_xticklabels([f"P{i+1}" for i in range(common_len)], fontsize=14)

        # √Çncoras Visuais
        ax_logo.axvline(1, color=PALETTE['danger'], linestyle='--', linewidth=2, alpha=0.6)
        if common_len > 2:
            ax_logo.axvline(common_len-1, color=PALETTE['danger'], linestyle='--', linewidth=2, alpha=0.6)
        ax_logo.text(1, ax_logo.get_ylim()[1], " √ÇNCORA P2", color=PALETTE['danger'], fontweight='bold')
    else:
        ax_logo.text(0.5, 0.5, "Erro: Tamanhos de pept√≠deos inconsistentes para gerar Logo", ha='center', fontsize=16)

    # --- LINHA 2: COMPARA√á√ÉO POPULACIONAL ---

    # 2.1 Scatter Plot
    ax_scatter = fig.add_subplot(gs[1, 0])

    sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color=PALETTE['neutral'],
                    alpha=0.2, s=40, ax=ax_scatter, label='Popula√ß√£o Geral', edgecolor=None)

    sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(60, 350), alpha=0.9, ax=ax_scatter, edgecolor='black')

    ax_scatter.set_xscale('log')
    ax_scatter.invert_xaxis()
    ax_scatter.set_title("2. Sele√ß√£o de Candidatos (Afinidade vs Imunogenicidade)", fontsize=20, color=PALETTE['dark'], loc='left')
    ax_scatter.set_xlabel("Afinidade (nM) - Log Invertido [Dir = Mais Forte]", fontsize=14)
    ax_scatter.set_ylabel("Potencial TCR (Visibilidade)", fontsize=14)
    ax_scatter.legend(loc='upper left', bbox_to_anchor=(0, 1), frameon=True)
    ax_scatter.grid(True, which="both", ls="--", alpha=0.3)

    # 2.2 Violin Plot
    ax_violin = fig.add_subplot(gs[1, 1])

    violin_data = pd.concat([
        pd.DataFrame({'Grupo': 'Popula√ß√£o', 'GRAVY': background['gravy']}),
        pd.DataFrame({'Grupo': 'Top 100', 'GRAVY': TOP_100['gravy']})
    ])

    sns.violinplot(data=violin_data, x='Grupo', y='GRAVY', palette=[PALETTE['neutral'], PALETTE['success']], ax=ax_violin, inner='box')
    ax_violin.set_title("3. Perfil de Solubilidade (GRAVY)", fontsize=20, color=PALETTE['dark'], loc='left')
    ax_violin.axhline(0, color='black', linestyle=':', label='Hidrof√≥bico > 0')

    # --- LINHA 3: RADAR CHART (A ELITE TOP 5) ---
    ax_radar = fig.add_subplot(gs[2, :], polar=True)

    top5_norm = normalize_for_radar(TOP_5)
    labels = ['Afinidade\n(Binding)', 'Score MHC\n(Processing)', 'Potencial TCR\n(Recognition)', 'Estabilidade\n(GRAVY)', 'Peso Mol.\n(Size)']
    num_vars = len(labels)

    angles = [n / float(num_vars) * 2 * pi for n in range(num_vars)]
    angles += angles[:1]

    colors = sns.color_palette("bright", 5)

    for i, (idx, row) in enumerate(top5_norm.iterrows()):
        values = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist()
        values += values[:1]
        ax_radar.plot(angles, values, linewidth=2, label=f"Rank #{i+1}: {row['peptide']}", color=colors[i])
        ax_radar.fill(angles, values, color=colors[i], alpha=0.1)

    ax_radar.set_xticks(angles[:-1])
    ax_radar.set_xticklabels(labels, size=14, fontweight='bold')
    ax_radar.set_title("4. Comparativo Multidimensional (Top 5 Campe√µes)", fontsize=22, color=PALETTE['dark'], pad=20)
    ax_radar.legend(loc='upper right', bbox_to_anchor=(1.1, 1.1), fontsize=12)

    # --- LINHA 4: DETALHAMENTO (TOP 20) ---
    # Heatmap
    ax_heat = fig.add_subplot(gs[3, 0])
    peps_20 = TOP_20['peptide'].tolist()
    sim_matrix = np.zeros((20, 20))
    for i in range(20):
        for j in range(20):
            sim_matrix[i, j] = lev_dist(peps_20[i], peps_20[j])

    sns.heatmap(sim_matrix, ax=ax_heat, cmap="mako_r", annot=True, fmt=".0f",
                cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'})
    ax_heat.set_title("5. Redund√¢ncia / Diversidade Viral (Top 20)", fontsize=20, color=PALETTE['dark'], loc='left')
    ax_heat.set_xticks([])
    ax_heat.set_yticks([])

    # Tabela
    ax_table = fig.add_subplot(gs[3, 1])
    ax_table.axis('off')
    col_show = ['peptide', 'affinity_nm', 'final_rank_score']
    tbl_data = TOP_20[col_show].copy()
    tbl_data['affinity_nm'] = tbl_data['affinity_nm'].apply(lambda x: f"{x:.1f} nM")
    tbl_data['final_rank_score'] = tbl_data['final_rank_score'].apply(lambda x: f"{x:.4f}")

    table = ax_table.table(cellText=tbl_data.values, colLabels=["Pept√≠deo", "Afinidade", "Score Final"],
                           loc='center', cellLoc='center', bbox=[0, 0, 1, 1])
    table.auto_set_font_size(False)
    table.set_fontsize(10)

    for (row, col), cell in table.get_celld().items():
        if row == 0:
            cell.set_text_props(weight='bold', color='white')
            cell.set_facecolor(PALETTE['primary'])
        elif row % 2 == 0:
            cell.set_facecolor('#ECF0F1')

    ax_table.set_title("6. Lista de Prioridade (Top 20)", fontsize=20, color=PALETTE['dark'], loc='left')

    plt.suptitle("DASHBOARD ESTRAT√âGICO DE SELE√á√ÉO VACINAL", fontsize=28, fontweight='bold', color=PALETTE['dark'], y=1.01)
    plt.savefig("Dashboard_Imunologia_Final.png", dpi=300, bbox_inches='tight')
    print("‚úÖ Dashboard gerado com sucesso: 'Dashboard_Imunologia_Final.png'")
    plt.show()

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        plot_master_dashboard(df_result)
    else:
        print("‚ö†Ô∏è Carregue os dados primeiro.")
except Exception as e:
    print(f"‚ùå Erro: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from mhcflurry import Class1PresentationPredictor

# --- 1. CONFIGURA√á√ÉO DO "ENSAIO supertipos HLA VIRTUAL" ---
# Lista de "Super-tipos" (Cobrem >90% da popula√ß√£o mundial)
GLOBAL_ALLELES = [
    "HLA-A*01:01", "HLA-A*02:01", "HLA-A*03:01", "HLA-A*24:02", # A-Types
    "HLA-B*07:02", "HLA-B*08:01", "HLA-B*15:01", "HLA-B*40:01", # B-Types
    "HLA-B*44:02", "HLA-B*58:01"  # B-Types cr√≠ticos
]

def run_promiscuity_analysis(df_input):
    print(f"--- INICIANDO AN√ÅLISE DE PROMISCUIDADE PARA {len(GLOBAL_ALLELES)} ALELOS GLOBAIS ---")

    # Pegamos apenas a ELITE (Top 10 ou Top 20) para economizar tempo computacional
    # Assumindo que o DF j√° tem o 'final_rank_score' calculado
    elite_candidates = df_input.sort_values(by='final_rank_score', ascending=False).head(15).copy()
    peptides = elite_candidates['peptide'].unique()

    print(f"Testando a Elite ({len(peptides)} pept√≠deos)...")

    predictor = Class1PresentationPredictor.load()

    # Lista para guardar resultados
    results_list = []

    # Loop "Um para Muitos" (Cada pept√≠deo contra TODOS os alelos)
    for allele in GLOBAL_ALLELES:
        print(f"  -> Simulando liga√ß√£o para {allele}...")
        try:
            # Predi√ß√£o
            preds = predictor.predict(
                peptides=peptides,
                alleles=[allele], # Passa como lista de 1 elemento para modo gen√≥tipo simples
                verbose=0
            )

            # Extrair afinidade (nM)
            # Nota: MHCflurry output pode variar, pegamos 'affinity'
            affinities = preds['affinity']

            for i, pep in enumerate(peptides):
                results_list.append({
                    'peptide': pep,
                    'allele': allele,
                    'affinity_nm': affinities.iloc[i]
                })
        except Exception as e:
            print(f"‚ö†Ô∏è Erro no alelo {allele}: {e}")

    # Cria DataFrame da Matriz
    df_promiscuity = pd.DataFrame(results_list)

    # Pivotar para formato Matriz (Linhas=Pept√≠deos, Colunas=Alelos)
    matrix = df_promiscuity.pivot(index='peptide', columns='allele', values='affinity_nm')

    # Reordenar linhas pelo Rank original do primeiro alelo (se poss√≠vel) para manter a l√≥gica
    matrix = matrix.reindex(peptides)

    return matrix

def plot_promiscuity_dashboard(matrix):
    # Configura√ß√£o Visual
    sns.set_style("white")
    fig = plt.figure(figsize=(16, 10))

    # T√≠tulo
    plt.suptitle("AN√ÅLISE DE PROMISCUIDADE: Potencial de Vacina Global", fontsize=20, fontweight='bold', y=0.98)

    # --- HEATMAP DE LIGA√á√ÉO CRUZADA ---
    # Log transform para visualiza√ß√£o (Afinidade varia muito)
    # Mas para leitura biol√≥gica, vamos colorir por categorias

    # Criar m√°scara para categorizar
    # <50nM = Forte (3), <500nM = Fraco (2), >500 = N√£o Liga (1)
    def categorize(x):
        if x < 50: return 1 # Forte
        elif x < 500: return 2 # Fraco
        else: return 3 # Nada

    # Heatmap customizado
    ax = plt.gca()

    # Plotamos o Log da afinidade para gradiente suave, mas anotamos o valor real
    sns.heatmap(matrix, annot=True, fmt=".0f", cmap="RdYlGn_r",
                norm=plt.Normalize(vmin=0, vmax=5000), # Trava escala em 5000nM (Ruim)
                linewidths=1, linecolor='white', cbar_kws={'label': 'Afinidade (nM) - Verde √© Melhor'})

    plt.title("Capacidade de Liga√ß√£o em M√∫ltiplos Alelos (Super-tipos)", fontsize=14)
    plt.ylabel("Top 15 Candidatos (Elite)")
    plt.xlabel("Painel de Alelos Representativos (OMS)")

    # Destaque visual para "Super Binders" (Linhas que s√£o quase todas verdes)
    plt.tight_layout()
    plt.savefig("Analise_Promiscuidade_Global.png", dpi=300)
    print("‚úÖ Gr√°fico 'Analise_Promiscuidade_Global.png' gerado.")
    plt.show()

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        # Roda a simula√ß√£o
        promiscuity_matrix = run_promiscuity_analysis(df_result)
        # Plota o resultado
        plot_promiscuity_dashboard(promiscuity_matrix)

        # An√°lise de Texto R√°pida
        print("\n--- INTERPRETA√á√ÉO DO TREINADOR ---")
        best_pep = promiscuity_matrix.mean(axis=1).idxmin()
        print(f"üèÜ O 'Super Binder' parece ser: {best_pep}")
        print("Se este pept√≠deo tiver colunas verdes em HLA-A e HLA-B, ele √© um candidato ouro.")
        print("Se ele for verde s√≥ no A*02 (primeira col) e vermelho no resto, ele √© restrito (menos valioso comercialmente).")

    else:
        print("‚ö†Ô∏è Carregue os dados (df_result) primeiro.")
except Exception as e:
    print(f"‚ùå Erro na an√°lise: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler

# --- CONFIGURA√á√ÉO VISUAL DE ALTO CONTRASTE ---
PALETTE = {
    'primary': '#2C3E50',   # Azul Petr√≥leo (Cabe√ßalhos)
    'success': '#27AE60',   # Verde (Dados positivos)
    'danger': '#C0392B',    # Vermelho (Alertas)
    'neutral': '#ECF0F1',   # Cinza Claro (Fundo alternado)
    'text': '#2C3E50'
}

# Fontes aumentadas para layout expandido
FONTS = {
    'title': {'fontsize': 30, 'fontweight': 'bold', 'color': PALETTE['primary']},
    'label': {'fontsize': 20, 'fontweight': 'bold', 'color': 'gray'},
    'tick':  {'fontsize': 16}
}

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'

def normalize_for_radar(df):
    scaler = MinMaxScaler()
    df_norm = df.copy()
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)
    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5
    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def generate_optimized_report(df, export_format='pdf'):
    print(f"--- GERANDO RELAT√ìRIO OTIMIZADO V3 ({export_format.upper()}) ---")

    # 1. DADOS
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    # 2. CONFIGURA√á√ÉO DA GRADE (Espa√ßo Extra para Tabela e Heatmap)
    # Aumentei altura para 65 e alterei os ratios para favorecer o final
    fig = plt.figure(figsize=(24, 65))

    # Ratios: [Logo=0.8, Scatter=1, Violin=0.8, Radar=1.6, Heatmap=2.2, Table=2.6]
    # O final do relat√≥rio agora tem muito mais peso visual.
    gs = fig.add_gridspec(6, 1, height_ratios=[0.8, 1, 0.8, 1.6, 2.2, 2.6], hspace=0.4)

    # --- 1. LOGO ---
    ax1 = fig.add_subplot(gs[0, 0])
    try: common_len = int(df['length'].mode()[0])
    except: common_len = 9
    seq_list = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]
    if seq_list:
        mat = logomaker.alignment_to_matrix(seq_list)
        info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
        logomaker.Logo(info_mat, ax=ax1, color_scheme='skylign_protein')
        ax1.set_title(f"1. Consenso Estrutural (Top 100)", **FONTS['title'], pad=20)
        ax1.set_ylabel("Bits", **FONTS['label'])
        ax1.set_xticks(range(common_len))
        ax1.set_xticklabels([f"P{i+1}" for i in range(common_len)], **FONTS['tick'])

    # --- 2. SCATTER ---
    ax2 = fig.add_subplot(gs[1, 0])
    sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='lightgray', s=60, alpha=0.5, ax=ax2)
    sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(150, 600), alpha=0.9, ax=ax2, edgecolor='k')
    ax2.set_xscale('log')
    ax2.invert_xaxis()
    ax2.set_title("2. Sele√ß√£o (Afinidade vs. Imunogenicidade)", **FONTS['title'], pad=20)
    ax2.set_xlabel("Afinidade (nM)", **FONTS['label'])
    ax2.set_ylabel("Potencial TCR", **FONTS['label'])
    ax2.legend(bbox_to_anchor=(1, 1), loc='upper left', fontsize=16)

    # --- 3. VIOLIN ---
    ax3 = fig.add_subplot(gs[2, 0])
    v_data = pd.concat([pd.DataFrame({'G': 'Popula√ß√£o', 'V': background['gravy']}),
                        pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})])
    sns.violinplot(data=v_data, x='G', y='V', palette=['lightgray', PALETTE['success']], ax=ax3)
    ax3.set_title("3. Estabilidade (Hidrofobicidade)", **FONTS['title'], pad=20)
    ax3.set_ylabel("GRAVY", **FONTS['label'])
    ax3.tick_params(axis='x', labelsize=20)

    # --- 4. RADAR ---
    ax4 = fig.add_subplot(gs[3, 0], projection='polar')
    top5_norm = normalize_for_radar(TOP_5)
    labels = ['Afinidade\n(Binding)', 'Score MHC\n(Processing)', 'Potencial TCR\n(Recognition)', 'Estabilidade\n(GRAVY)', 'Peso Mol.\n(Size)']
    angles = [n / float(5) * 2 * pi for n in range(5)]
    angles += angles[:1]
    colors = sns.color_palette("bright", 5)

    for i, (idx, row) in enumerate(top5_norm.iterrows()):
        val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist()
        val += val[:1]
        ax4.plot(angles, val, linewidth=4, label=f"#{i+1}: {row['peptide']}", color=colors[i])
        ax4.fill(angles, val, color=colors[i], alpha=0.1)

    ax4.set_xticks(angles[:-1])
    ax4.set_xticklabels(labels, size=18, weight='bold')
    ax4.set_title("4. Perfil Multidimensional (Top 5)", **FONTS['title'], pad=40)
    ax4.legend(bbox_to_anchor=(1.15, 1), loc='upper left', fontsize=16)

    # --- 5. HEATMAP (MAXIMIZADO) ---
    ax5 = fig.add_subplot(gs[4, 0])
    peps_20 = TOP_20['peptide'].tolist()
    sim_matrix = np.zeros((20, 20))
    for i in range(20):
        for j in range(20): sim_matrix[i, j] = lev_dist(peps_20[i], peps_20[j])

    # Heatmap com n√∫meros grandes e negrito
    sns.heatmap(sim_matrix, ax=ax5, cmap="mako_r", annot=True, fmt=".0f",
                annot_kws={"size": 16, "weight": "bold"}, # Fonte interna 16px Bold
                cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'})

    ax5.set_title("5. Diversidade e Redund√¢ncia (Top 20)", **FONTS['title'], pad=20)
    ax5.set_xticks([])
    ax5.set_yticks([])
    ax5.set_ylabel("Pept√≠deos (Ordenados por Rank)", **FONTS['label'])

    # --- 6. TABELA (LEGIBILIDADE TOTAL) ---
    ax6 = fig.add_subplot(gs[5, 0])
    ax6.axis('off')

    tbl_data = TOP_20[['peptide', 'affinity_nm', 'final_rank_score']].copy()
    tbl_data['affinity_nm'] = tbl_data['affinity_nm'].apply(lambda x: f"{x:.1f} nM")
    tbl_data['final_rank_score'] = tbl_data['final_rank_score'].apply(lambda x: f"{x:.4f}")

    # Tabela ocupa 100% da √°rea do subplot
    table = ax6.table(cellText=tbl_data.values, colLabels=["Pept√≠deo", "Afinidade", "Score Final"],
                      loc='center', cellLoc='center', bbox=[0, 0, 1, 1])

    table.auto_set_font_size(False)
    table.set_fontsize(22) # Fonte gigante para leitura sem zoom

    # Estiliza√ß√£o Profissional
    for (row, col), cell in table.get_celld().items():
        cell.set_height(0.05) # Altura fixa confort√°vel
        if row == 0:
            cell.set_facecolor(PALETTE['primary'])
            cell.set_text_props(color='white', weight='bold', size=24)
        elif row % 2 == 0:
            cell.set_facecolor(PALETTE['neutral']) # Zebra
        else:
            cell.set_facecolor('white')

    ax6.set_title("6. Lista Priorit√°ria (Dados Brutos)", **FONTS['title'], pad=20)

    # EXPORTA√á√ÉO
    filename = f"Relatorio_Final_V3.{export_format}"
    plt.savefig(filename, dpi=300, bbox_inches='tight')
    print(f"‚úÖ Relat√≥rio salvo: {filename}")
    plt.show()

# --- COMANDO DE EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        # ESCOLHA SEU FORMATO AQUI: 'pdf' ou 'tiff'
        generate_optimized_report(df_result, export_format='pdf')

        # Para gerar TIFF tamb√©m, descomente:
        # generate_optimized_report(df_result, export_format='tiff')
    else:
        print("‚ö†Ô∏è Carregue os dados primeiro (df_result).")
except Exception as e:
    print(f"‚ùå Erro: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler

# --- CONFIGURA√á√ÉO DE ESTILO ---
PALETTE = {
    'primary': '#2C3E50',   # Azul Escuro
    'success': '#27AE60',   # Verde
    'highlight': '#F1C40F', # Amarelo Ouro (Elite)
    'danger': '#E74C3C',    # Vermelho
    'neutral': '#BDC3C7',   # Cinza
    'text': '#34495E'
}

FONTS = {
    'title': {'fontsize': 28, 'fontweight': 'bold', 'color': PALETTE['primary']},
    'subtitle': {'fontsize': 20, 'fontweight': 'bold', 'color': 'gray'},
    'label': {'fontsize': 16, 'fontweight': 'bold'},
    'tick':  {'fontsize': 14}
}

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'

def normalize_for_radar(df):
    scaler = MinMaxScaler()
    df_norm = df.copy()
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)
    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5
    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def generate_final_v4(df, export_format='pdf'):
    print(f"--- GERANDO RELAT√ìRIO V4: TOP 100 & AJUSTES ({export_format.upper()}) ---")

    # 1. PREPARA√á√ÉO
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    # 2. LAYOUT EXPANDIDO
    # Aumentei altura para 75 para caber a tabela gigante no final
    fig = plt.figure(figsize=(26, 75))

    # Ratios ajustados: Logo maior (1.2), Tabela final enorme (4.0)
    gs = fig.add_gridspec(7, 1, height_ratios=[1.2, 1, 1, 1.8, 2, 0.5, 4.0], hspace=0.5)

    # --- 1. SEQUENCE LOGO (Mais Espa√ßo) ---
    ax1 = fig.add_subplot(gs[0, 0])
    try: common_len = int(df['length'].mode()[0])
    except: common_len = 9

    seq_list = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]
    if seq_list:
        mat = logomaker.alignment_to_matrix(seq_list)
        info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
        # Logo mais limpo
        logomaker.Logo(info_mat, ax=ax1, color_scheme='skylign_protein', vpad=0.1)

        ax1.set_title(f"1. Consenso Estrutural (Top 100)", **FONTS['title'], pad=20)
        ax1.set_ylabel("Bits", **FONTS['label'])
        ax1.set_xticks(range(common_len))
        ax1.set_xticklabels([f"P{i+1}" for i in range(common_len)], **FONTS['tick'])
        # √Çncoras
        for p in [1, common_len-1]:
            ax1.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2, alpha=0.6)

    # --- 2. SCATTER PLOT ---
    ax2 = fig.add_subplot(gs[1, 0])
    sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='lightgray', s=50, alpha=0.4, ax=ax2)
    sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(100, 500), alpha=0.9, ax=ax2, edgecolor='k')
    ax2.set_xscale('log')
    ax2.invert_xaxis()
    ax2.set_title("2. Sele√ß√£o (Afinidade vs. Imunogenicidade)", **FONTS['title'])
    ax2.legend(bbox_to_anchor=(1, 1), loc='upper left', fontsize=14)

    # --- 3. VIOLIN COM DESTAQUE TOP 20 ---
    ax3 = fig.add_subplot(gs[2, 0])
    v_data = pd.concat([
        pd.DataFrame({'G': 'Popula√ß√£o', 'V': background['gravy']}),
        pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})
    ])
    sns.violinplot(data=v_data, x='G', y='V', palette=['lightgray', PALETTE['success']], ax=ax3, inner=None)

    # Overlay: Top 20 como pontos dourados sobre o violino do Top 100
    # O eixo X do violinplot √© categ√≥rico: 0='Popula√ß√£o', 1='Top 100'
    # Usamos stripplot apenas no Top 100 (x=1)
    sns.stripplot(x=[1]*len(TOP_20), y=TOP_20['gravy'], color=PALETTE['highlight'],
                  size=10, jitter=0.05, ax=ax3, edgecolor='black', linewidth=1, label='Top 20 Elite')

    ax3.set_title("3. Estabilidade (Pontos Dourados = Top 20)", **FONTS['title'])
    ax3.set_ylabel("GRAVY Score", **FONTS['label'])
    ax3.legend(loc='upper left', fontsize=14)

    # --- 4. RADAR (LEGENDAS EXTERNAS) ---
    ax4 = fig.add_subplot(gs[3, 0], projection='polar')
    top5_norm = normalize_for_radar(TOP_5)
    labels = ['Afinidade', 'MHC Score', 'TCR Pot.', 'Estabilidade', 'Peso Mol.']
    angles = [n / float(5) * 2 * pi for n in range(5)]
    angles += angles[:1]
    colors = sns.color_palette("bright", 5)

    for i, (idx, row) in enumerate(top5_norm.iterrows()):
        val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist()
        val += val[:1]
        ax4.plot(angles, val, linewidth=3, label=f"#{i+1}: {row['peptide']}", color=colors[i])
        ax4.fill(angles, val, color=colors[i], alpha=0.1)

    ax4.set_xticks(angles[:-1])
    ax4.set_xticklabels(labels, size=16, weight='bold')
    ax4.set_title("4. Perfil Multidimensional (Top 5)", **FONTS['title'], pad=40)
    # Legenda bem afastada
    ax4.legend(bbox_to_anchor=(1.3, 1), loc='upper right', fontsize=14, title="Candidatos")

    # --- 5. HEATMAP ---
    ax5 = fig.add_subplot(gs[4, 0])
    peps_20 = TOP_20['peptide'].tolist()
    sim_matrix = np.zeros((20, 20))
    for i in range(20):
        for j in range(20): sim_matrix[i, j] = lev_dist(peps_20[i], peps_20[j])

    sns.heatmap(sim_matrix, ax=ax5, cmap="mako_r", annot=True, fmt=".0f",
                annot_kws={"size": 14, "weight": "bold"}, cbar=False)
    ax5.set_title("5. Matriz de Redund√¢ncia (Top 20)", **FONTS['title'])
    ax5.set_xticks([])
    ax5.set_yticks([])

    # --- SEPARADOR ---
    ax_sep = fig.add_subplot(gs[5, 0])
    ax_sep.axis('off')
    ax_sep.text(0.5, 0.5, "‚¨á RELAT√ìRIO COMPLETO: TOP 100 CANDIDATOS ‚¨á",
                ha='center', va='center', fontsize=30, weight='bold', color=PALETTE['primary'])

    # --- 6. TABELA TOP 100 (ESTRAT√âGIA DE COLUNAS) ---
    ax6 = fig.add_subplot(gs[6, 0])
    ax6.axis('off')

    # Preparar dados: Pept√≠deo, Afinidade, Score
    # Dividir em 4 colunas de 25 linhas para caber na tela
    cols_data = ['peptide', 'affinity_nm', 'final_rank_score']
    t100_data = TOP_100[cols_data].copy()
    t100_data['affinity_nm'] = t100_data['affinity_nm'].apply(lambda x: f"{x:.1f}")
    t100_data['final_rank_score'] = t100_data['final_rank_score'].apply(lambda x: f"{x:.4f}")

    # Criar lista de listas para a tabela (4 blocos lado a lado)
    # Estrutura visual: [Pep Af Sc] | [Pep Af Sc] | [Pep Af Sc] | [Pep Af Sc]

    n_rows = 25
    table_matrix = []
    # Cabe√ßalho composto
    header = ["Pept√≠deo", "Afinidade", "Score"] * 4

    for r in range(n_rows):
        row_content = []
        for block in range(4): # 0, 1, 2, 3
            idx = r + (block * n_rows)
            if idx < 100:
                row_content.extend(t100_data.iloc[idx].values)
            else:
                row_content.extend(["", "", ""])
        table_matrix.append(row_content)

    # Desenhar Tabela
    table = ax6.table(cellText=table_matrix, colLabels=header,
                      loc='center', cellLoc='center', bbox=[0, 0, 1, 1])

    table.auto_set_font_size(False)
    table.set_fontsize(11)

    # Estiliza√ß√£o Complexa
    for (row, col), cell in table.get_celld().items():
        # Altura da linha
        cell.set_height(0.038)

        # Cabe√ßalho
        if row == 0:
            cell.set_facecolor(PALETTE['primary'])
            cell.set_text_props(color='white', weight='bold')
        # Colunas de separa√ß√£o (a cada 3 colunas, criar uma borda visual?)
        # Vamos pintar colunas alternadas levemente para guiar o olho
        elif col in [0, 1, 2]: # Bloco 1
            cell.set_facecolor('#F4F6F7' if row % 2 == 0 else 'white')
        elif col in [3, 4, 5]: # Bloco 2
            cell.set_facecolor('#EAECEE' if row % 2 == 0 else '#F2F4F4')
        elif col in [6, 7, 8]: # Bloco 3
            cell.set_facecolor('#F4F6F7' if row % 2 == 0 else 'white')
        else: # Bloco 4
            cell.set_facecolor('#EAECEE' if row % 2 == 0 else '#F2F4F4')

        # Destaque para Afinidade < 50nM (Ouro)
        try:
            # Tenta pegar o valor da afinidade nas colunas certas (1, 4, 7, 10) e pintar texto
            if row > 0 and col in [1, 4, 7, 10]:
                val = float(cell.get_text().get_text())
                if val < 50:
                    cell.set_text_props(weight='bold', color=PALETTE['success'])
        except:
            pass

    # Salvar
    filename = f"Relatorio_Final_V4_Top100.{export_format}"
    plt.savefig(filename, dpi=300, bbox_inches='tight')
    print(f"‚úÖ Arquivo gerado: {filename}")
    plt.show()

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        generate_final_v4(df_result, export_format='pdf')
        # Para imagem raster (TIFF), descomente:
        # generate_final_v4(df_result, export_format='tiff')
    else:
        print("‚ö†Ô∏è Dados n√£o encontrados.")
except Exception as e:
    print(f"‚ùå Erro: {e}")
    import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler
import textwrap

# --- CONFIGURA√á√ÉO DE ESTILO E CORES ---
PALETTE = {
    'primary': '#2C3E50',   # Azul Escuro (T√≠tulos)
    'secondary': '#7F8C8D', # Cinza (Texto explicativo)
    'success': '#27AE60',   # Verde (Dados positivos)
    'highlight': '#F1C40F', # Dourado (Elite)
    'danger': '#C0392B',    # Vermelho
    'neutral': '#ECF0F1'    # Fundo
}

FONTS = {
    'title': {'fontsize': 26, 'fontweight': 'bold', 'color': PALETTE['primary']},
    'caption_title': {'fontsize': 16, 'fontweight': 'bold', 'color': '#E67E22'}, # Laranja queimado
    'caption_body': {'fontsize': 14, 'color': '#34495E', 'style': 'italic'}
}

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'

def normalize_for_radar(df):
    scaler = MinMaxScaler()
    df_norm = df.copy()
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)
    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5
    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def add_caption(ax, title, text, y_pos=-0.25):
    """Adiciona um bloco de texto explicativo abaixo do gr√°fico."""
    # Quebra o texto para n√£o sair da margem
    wrapper = textwrap.TextWrapper(width=90)
    text = wrapper.fill(text)

    # T√≠tulo da Legenda
    ax.text(0, y_pos, title.upper(), transform=ax.transAxes, ha='left', va='top', **FONTS['caption_title'])
    # Corpo da Legenda
    ax.text(0, y_pos - 0.03, text, transform=ax.transAxes, ha='left', va='top', **FONTS['caption_body'])

def generate_detailed_report(df, export_format='pdf'):
    print(f"--- GERANDO RELAT√ìRIO V5: DETALHADO E NARRATIVO ({export_format.upper()}) ---")

    # 1. PREPARA√á√ÉO
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    # 2. LAYOUT (Aumentado para caber textos)
    fig = plt.figure(figsize=(24, 85))
    # Height ratios ajustados para dar espa√ßo aos textos
    gs = fig.add_gridspec(7, 1, height_ratios=[1.2, 1.2, 1, 1.8, 2.2, 0.5, 4.0], hspace=0.6)

    # --- 1. SEQUENCE LOGO ---
    ax1 = fig.add_subplot(gs[0, 0])
    try: common_len = int(df['length'].mode()[0])
    except: common_len = 9

    seq_list = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]
    if seq_list:
        mat = logomaker.alignment_to_matrix(seq_list)
        info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
        logomaker.Logo(info_mat, ax=ax1, color_scheme='skylign_protein', vpad=0.1)

        ax1.set_title(f"1. Consenso Estrutural (Top 100 Candidatos)", **FONTS['title'], pad=20)
        ax1.set_ylabel("Bits (Conserva√ß√£o)", fontsize=16)
        ax1.set_xticks(range(common_len))
        ax1.set_xticklabels([f"P{i+1}" for i in range(common_len)], fontsize=14)

        # √Çncoras
        for p in [1, common_len-1]:
            ax1.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2, alpha=0.6)

        # LEGENDA NARRATIVA 1
        desc1 = ("Este gr√°fico mostra quais amino√°cidos s√£o essenciais para a liga√ß√£o. "
                 "As letras gigantes nas posi√ß√µes P2 e P9 indicam as '√¢ncoras' onde o pept√≠deo se fixa no MHC. "
                 "A varia√ß√£o no meio (P4-P6) √© desej√°vel pois √© onde o sistema imune (TCR) interage.")
        add_caption(ax1, "Interpreta√ß√£o Estrutural:", desc1, y_pos=-0.15)

    # --- 2. SCATTER PLOT ---
    ax2 = fig.add_subplot(gs[1, 0])
    sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='lightgray', s=50, alpha=0.4, ax=ax2, label='Fundo (Descartados)')
    sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(100, 500), alpha=0.9, ax=ax2, edgecolor='k')
    ax2.set_xscale('log')
    ax2.invert_xaxis()
    ax2.set_title("2. Sele√ß√£o de Elite (Afinidade vs. Imunogenicidade)", **FONTS['title'])
    ax2.legend(bbox_to_anchor=(1, 1), loc='upper left', fontsize=14)

    # LEGENDA NARRATIVA 2
    desc2 = ("Cada ponto √© um pept√≠deo. Buscamos o 'Quadrante M√°gico' (Canto Superior Direito): "
             "Pept√≠deos que ligam muito forte (baixa afinidade nM, eixo X) E possuem alta visibilidade "
             "para c√©lulas T (eixo Y). Pontos maiores indicam maior peso molecular.")
    add_caption(ax2, "Crit√©rio de Sele√ß√£o:", desc2, y_pos=-0.15)

    # --- 3. VIOLIN COM DESTAQUE ---
    ax3 = fig.add_subplot(gs[2, 0])
    v_data = pd.concat([pd.DataFrame({'G': 'Popula√ß√£o', 'V': background['gravy']}),
                        pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})])
    sns.violinplot(data=v_data, x='G', y='V', palette=['lightgray', PALETTE['success']], ax=ax3, inner=None)
    sns.stripplot(x=[1]*len(TOP_20), y=TOP_20['gravy'], color=PALETTE['highlight'],
                  size=12, jitter=0.05, ax=ax3, edgecolor='black', linewidth=1, label='Top 20 Elite')

    ax3.set_title("3. An√°lise de Solubilidade e Estabilidade", **FONTS['title'])
    ax3.set_ylabel("√çndice GRAVY", fontsize=16)
    ax3.axhline(0, color='black', linestyle=':', label='Neutro')
    ax3.legend(loc='upper left', fontsize=14)

    # LEGENDA NARRATIVA 3
    desc3 = ("O √≠ndice GRAVY mede a hidrofobicidade. Valores muito positivos (>1.5) indicam pept√≠deos que podem "
             "precipitar na s√≠ntese. Note como os pontos dourados (Top 20) est√£o concentrados em uma zona segura "
             "pr√≥xima da neutralidade ou levemente hidrof√≥bica.")
    add_caption(ax3, "Viabilidade de S√≠ntese:", desc3, y_pos=-0.15)

    # --- 4. RADAR ---
    ax4 = fig.add_subplot(gs[3, 0], projection='polar')
    top5_norm = normalize_for_radar(TOP_5)
    labels = ['Afinidade\n(Binding)', 'MHC Score\n(Processing)', 'TCR Pot.\n(Recognition)', 'Estabilidade\n(GRAVY)', 'Peso Mol.\n(Size)']
    angles = [n / float(5) * 2 * pi for n in range(5)]
    angles += angles[:1]
    colors = sns.color_palette("bright", 5)

    for i, (idx, row) in enumerate(top5_norm.iterrows()):
        val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist()
        val += val[:1]
        ax4.plot(angles, val, linewidth=3, label=f"Rank #{i+1}: {row['peptide']}", color=colors[i])
        ax4.fill(angles, val, color=colors[i], alpha=0.1)

    ax4.set_xticks(angles[:-1])
    ax4.set_xticklabels(labels, size=16, weight='bold')
    ax4.set_title("4. Equil√≠brio Multidimensional (Top 5)", **FONTS['title'], pad=40)
    ax4.legend(bbox_to_anchor=(1.3, 1), loc='upper right', fontsize=14, title="Candidatos")

    # LEGENDA NARRATIVA 4 (Manual via fig.text pois polar axes √© chato com coordenadas)
    # Colocamos um pouco abaixo do gr√°fico polar
    desc4 = ("O gr√°fico de radar permite ver o equil√≠brio do candidato. Buscamos pol√≠gonos com a maior √°rea poss√≠vel. "
             "Um candidato ideal n√£o √© apenas forte em afinidade, mas balanceado em processamento e estabilidade.")
    # Ajuste manual de Y para o Radar
    add_caption(ax4, "An√°lise Hol√≠stica:", desc4, y_pos=-0.15)

    # --- 5. HEATMAP ---
    ax5 = fig.add_subplot(gs[4, 0])
    peps_20 = TOP_20['peptide'].tolist()
    sim_matrix = np.zeros((20, 20))
    for i in range(20):
        for j in range(20): sim_matrix[i, j] = lev_dist(peps_20[i], peps_20[j])

    sns.heatmap(sim_matrix, ax=ax5, cmap="mako_r", annot=True, fmt=".0f",
                annot_kws={"size": 14, "weight": "bold"}, cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'})
    ax5.set_title("5. Diversidade e Redund√¢ncia (Top 20)", **FONTS['title'])
    ax5.set_xticks([]); ax5.set_yticks([])
    ax5.set_ylabel("Matriz Cruzada", fontsize=16)

    # LEGENDA NARRATIVA 5
    desc5 = ("Esta matriz mostra a dist√¢ncia de edi√ß√£o (Levenshtein) entre os pept√≠deos. "
             "Cores claras (n√∫meros altos) indicam sequ√™ncias muito diferentes. "
             "Isso √© vital para garantir que a vacina cubra variantes virais distintas e n√£o foque apenas em um ep√≠topo.")
    add_caption(ax5, "Cobertura Viral:", desc5, y_pos=-0.10)

    # --- SEPARADOR ---
    ax_sep = fig.add_subplot(gs[5, 0])
    ax_sep.axis('off')
    ax_sep.text(0.5, 0.5, "‚¨á DADOS BRUTOS PARA S√çNTESE (TOP 100) ‚¨á",
                ha='center', va='center', fontsize=28, weight='bold', color=PALETTE['primary'])

    # --- 6. TABELA GIGANTE ---
    ax6 = fig.add_subplot(gs[6, 0])
    ax6.axis('off')
    cols_data = ['peptide', 'affinity_nm', 'final_rank_score']
    t100_data = TOP_100[cols_data].copy()
    t100_data['affinity_nm'] = t100_data['affinity_nm'].apply(lambda x: f"{x:.1f}")
    t100_data['final_rank_score'] = t100_data['final_rank_score'].apply(lambda x: f"{x:.4f}")

    n_rows = 25
    table_matrix = []
    header = ["Pept√≠deo", "Afinidade (nM)", "Score"] * 4

    for r in range(n_rows):
        row_content = []
        for block in range(4):
            idx = r + (block * n_rows)
            if idx < 100: row_content.extend(t100_data.iloc[idx].values)
            else: row_content.extend(["", "", ""])
        table_matrix.append(row_content)

    table = ax6.table(cellText=table_matrix, colLabels=header, loc='center', cellLoc='center', bbox=[0, 0, 1, 1])
    table.auto_set_font_size(False); table.set_fontsize(11)

    for (row, col), cell in table.get_celld().items():
        cell.set_height(0.038)
        if row == 0:
            cell.set_facecolor(PALETTE['primary'])
            cell.set_text_props(color='white', weight='bold')
        elif col in [0, 1, 2, 6, 7, 8]: cell.set_facecolor('#F4F6F7' if row % 2 == 0 else 'white')
        else: cell.set_facecolor('#EAECEE' if row % 2 == 0 else '#F2F4F4')

        try:
            if row > 0 and col in [1, 4, 7, 10] and float(cell.get_text().get_text()) < 50:
                cell.set_text_props(weight='bold', color=PALETTE['success'])
        except: pass

    # LEGENDA NARRATIVA 6
    desc6 = ("Lista completa priorizada. Valores de Afinidade em VERDE indicam ligantes fortes (<50nM). "
             "O Score Final combina afinidade, processamento e estabilidade.")
    add_caption(ax6, "Cat√°logo de Alvos:", desc6, y_pos=-0.05)

    filename = f"Relatorio_Final_Narrativo_V5.{export_format}"
    plt.savefig(filename, dpi=300, bbox_inches='tight')
    print(f"‚úÖ Relat√≥rio V5 salvo: {filename}")
    plt.show()

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        generate_detailed_report(df_result, export_format='pdf')
        # generate_detailed_report(df_result, export_format='tiff')
    else:
        print("‚ö†Ô∏è Dados n√£o encontrados.")
except Exception as e:
    print(f"‚ùå Erro: {e}")
    import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler
import textwrap

# --- CONFIGURA√á√ïES GLOBAIS ---
PALETTE = {
    'primary': '#2C3E50',
    'success': '#27AE60',
    'highlight': '#F1C40F',
    'danger': '#C0392B',
    'text': '#34495E'
}

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'

# --- FUN√á√ïES AUXILIARES ---
def normalize_for_radar(df):
    scaler = MinMaxScaler()
    df_norm = df.copy()
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)
    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5
    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def create_narrative_box(fig, title, narrative_text, key_peptides=None):
    """Cria o rodap√© narrativo em cada p√°gina."""
    # Desenha uma linha separadora
    line = plt.Line2D([0.05, 0.95], [0.25, 0.25], transform=fig.transFigure, color=PALETTE['primary'], linewidth=2)
    fig.add_artist(line)

    # T√≠tulo da Se√ß√£o
    fig.text(0.05, 0.22, title.upper(), fontsize=18, fontweight='bold', color=PALETTE['primary'])

    # Texto Descritivo
    wrapper = textwrap.TextWrapper(width=110)
    formatted_text = wrapper.fill(narrative_text)
    fig.text(0.05, 0.18, formatted_text, fontsize=14, color=PALETTE['text'], va='top', style='italic')

    # Lista de Pept√≠deos Chave (se houver)
    if key_peptides:
        fig.text(0.05, 0.08, "PEPT√çDEOS EM DESTAQUE NESTA AN√ÅLISE:", fontsize=12, fontweight='bold', color='#E67E22')
        pep_str = "  |  ".join([f"{p['peptide']} (Rank #{i+1})" for i, p in key_peptides.iterrows()])
        fig.text(0.05, 0.05, pep_str, fontsize=12, family='monospace', color='black')

def generate_multipage_report(df, filename="Relatorio_Bioinfo_Analitico_V6.pdf"):
    print(f"--- GERANDO LIVRO PDF: {filename} ---")

    # 1. PREPARA√á√ÉO DOS DADOS
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    # INICIA O PDF
    with PdfPages(filename) as pdf:

        # === P√ÅGINA 1: CAPA ===
        fig = plt.figure(figsize=(11.69, 8.27)) # A4 Landscape
        fig.text(0.5, 0.6, "RELAT√ìRIO DE SELE√á√ÉO VACINAL", ha='center', fontsize=40, fontweight='bold', color=PALETTE['primary'])
        fig.text(0.5, 0.5, "An√°lise Computacional de Ep√≠topos de C√©lulas T", ha='center', fontsize=20, color='gray')
        fig.text(0.5, 0.4, f"Total de Candidatos Processados: {len(df)}", ha='center', fontsize=16)
        fig.text(0.5, 0.3, "Abordagem: Consensus Binding + Imunogenicidade + Estabilidade", ha='center', fontsize=14)
        plt.axis('off')
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 2: SEQUENCE LOGO ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1]) # 75% Gr√°fico, 25% Texto
        ax = fig.add_subplot(gs[0])

        try: common_len = int(df['length'].mode()[0])
        except: common_len = 9
        seq_list = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]

        if seq_list:
            mat = logomaker.alignment_to_matrix(seq_list)
            info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
            logomaker.Logo(info_mat, ax=ax, color_scheme='skylign_protein')
            ax.set_title(f"Impress√£o Digital do Alvo (Consenso dos Top 100)", fontsize=20, fontweight='bold', pad=20)
            ax.set_ylabel("Bits de Informa√ß√£o", fontsize=14)
            ax.set_xticks(range(common_len))
            ax.set_xticklabels([f"Posi√ß√£o {i+1}" for i in range(common_len)], fontsize=12)
            # √Çncoras
            for p in [1, common_len-1]:
                ax.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2)
                ax.text(p, ax.get_ylim()[1], "√ÇNCONA", color=PALETTE['danger'], ha='center', fontweight='bold')

        # Narrativa
        narrative = ("ESTRUTURA: O gr√°fico acima revela as regras moleculares para a liga√ß√£o. "
                     "Observe as posi√ß√µes marcadas como √ÇNCORA (usualmente P2 e P9). As letras grandes indicam "
                     "amino√°cidos obrigat√≥rios para a fixa√ß√£o no MHC. A diversidade nas posi√ß√µes centrais "
                     "sugere que selecionamos ep√≠topos capazes de serem reconhecidos por diferentes clones de c√©lulas T.")
        create_narrative_box(fig, "1. Valida√ß√£o Estrutural", narrative)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 3: SCATTER PLOT (SELE√á√ÉO) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1])
        ax = fig.add_subplot(gs[0])

        sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='lightgray', s=50, alpha=0.5, ax=ax, label='Popula√ß√£o Geral')
        sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                        palette='viridis', size='mw', sizes=(100, 600), alpha=0.9, ax=ax, edgecolor='k')

        ax.set_xscale('log')
        ax.invert_xaxis()
        ax.set_title("Sele√ß√£o de Elite: Afinidade vs. Imunogenicidade", fontsize=20, fontweight='bold')
        ax.set_xlabel("Afinidade (nM) - [Esquerda=Fraco ... Direita=Forte]", fontsize=14, fontweight='bold')
        ax.set_ylabel("Potencial TCR (Visibilidade)", fontsize=14, fontweight='bold')
        ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', fontsize=12)

        narrative = ("CRIT√âRIO DE ESCOLHA: Cada ponto representa um candidato. Buscamos o 'Quadrante de Ouro' "
                     "(Canto Superior Direito). Estes s√£o os pept√≠deos que ligam fortemente (Afinidade < 50nM) "
                     "E possuem res√≠duos volumosos expostos para ativa√ß√£o imune. Os pept√≠deos listados abaixo "
                     "s√£o os l√≠deres absolutos neste crit√©rio.")
        create_narrative_box(fig, "2. O Funil de Decis√£o", narrative, key_peptides=TOP_5)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 4: VIOLIN PLOT (ESTABILIDADE) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1])
        ax = fig.add_subplot(gs[0])

        v_data = pd.concat([pd.DataFrame({'G': 'Popula√ß√£o', 'V': background['gravy']}),
                            pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})])
        sns.violinplot(data=v_data, x='G', y='V', palette=['lightgray', PALETTE['success']], ax=ax, inner=None)
        sns.stripplot(x=[1]*len(TOP_20), y=TOP_20['gravy'], color=PALETTE['highlight'],
                      size=12, jitter=0.05, ax=ax, edgecolor='black', linewidth=1, label='Top 20 Elite')

        ax.set_title("Comparativo de Solubilidade (GRAVY)", fontsize=20, fontweight='bold')
        ax.set_ylabel("√çndice de Hidrofobicidade", fontsize=14)
        ax.axhline(0, color='black', linestyle=':', label='Neutro')
        ax.legend(fontsize=12)

        narrative = ("MANUFATURABILIDADE: O √≠ndice GRAVY prediz a dificuldade de s√≠ntese. "
                     "Valores muito altos (>1.5) indicam risco de agrega√ß√£o. Note como nossos Top 20 (pontos dourados) "
                     "foram selecionados para evitar extremos hidrof√≥bicos, garantindo uma vacina est√°vel e sol√∫vel.")
        create_narrative_box(fig, "3. Controle de Qualidade Qu√≠mica", narrative)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 5: RADAR CHART ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1])
        ax = fig.add_subplot(gs[0], projection='polar')

        top5_norm = normalize_for_radar(TOP_5)
        labels = ['Afinidade\n(Binding)', 'Score MHC\n(Processing)', 'Potencial TCR\n(Recognition)', 'Estabilidade\n(GRAVY)', 'Peso Mol.\n(Size)']
        angles = [n / float(5) * 2 * pi for n in range(5)]
        angles += angles[:1]
        colors = sns.color_palette("bright", 5)

        for i, (idx, row) in enumerate(top5_norm.iterrows()):
            val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist()
            val += val[:1]
            ax.plot(angles, val, linewidth=4, label=f"Rank #{i+1}: {row['peptide']}", color=colors[i])
            ax.fill(angles, val, color=colors[i], alpha=0.1)

        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, size=14, weight='bold')
        ax.set_title("Perfil Multidimensional (Top 5)", fontsize=20, fontweight='bold', pad=30)
        ax.legend(bbox_to_anchor=(1.15, 1), loc='upper left', fontsize=12, title="Legenda")

        narrative = ("EQUIL√çBRIO: Nenhum candidato √© perfeito em tudo. O Rank #1 geralmente apresenta a maior √°rea "
                     "no pol√≠gono. Use este gr√°fico para decidir: se voc√™ precisa de pot√™ncia bruta, escolha o pico em 'Afinidade'. "
                     "Se precisa de seguran√ßa, olhe para 'Estabilidade'.")
        create_narrative_box(fig, "4. An√°lise Hol√≠stica", narrative, key_peptides=TOP_5)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 6: HEATMAP DE DIVERSIDADE ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1])
        ax = fig.add_subplot(gs[0])

        peps_20 = TOP_20['peptide'].tolist()
        sim_matrix = np.zeros((20, 20))
        for i in range(20):
            for j in range(20): sim_matrix[i, j] = lev_dist(peps_20[i], peps_20[j])

        sns.heatmap(sim_matrix, ax=ax, cmap="mako_r", annot=True, fmt=".0f",
                    annot_kws={"size": 12, "weight": "bold"}, cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'})
        ax.set_title("Matriz de Redund√¢ncia (Top 20)", fontsize=20, fontweight='bold')
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_ylabel("Cruzamento de Sequ√™ncias", fontsize=14)

        narrative = ("COBERTURA VIRAL: Esta matriz evita que escolhamos 20 variantes da mesma sequ√™ncia. "
                     "N√∫meros altos (Cores claras) indicam sequ√™ncias muito diferentes entre si. "
                     "Para uma vacina de amplo espectro, selecione pept√≠deos que tenham alta dist√¢ncia de edi√ß√£o entre si.")
        create_narrative_box(fig, "5. Diversidade de Ep√≠topos", narrative)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 7: TABELA FINAL (Dividida em 4 colunas) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        ax = fig.add_subplot(111)
        ax.axis('off')

        # Tabela em 4 blocos
        cols_data = ['peptide', 'affinity_nm', 'final_rank_score']
        t100_data = TOP_100[cols_data].copy()
        t100_data['affinity_nm'] = t100_data['affinity_nm'].apply(lambda x: f"{x:.1f}")
        t100_data['final_rank_score'] = t100_data['final_rank_score'].apply(lambda x: f"{x:.4f}")

        n_rows = 25
        table_matrix = []
        header = ["Pept√≠deo", "nM", "Score"] * 4

        for r in range(n_rows):
            row_content = []
            for block in range(4):
                idx = r + (block * n_rows)
                if idx < 100: row_content.extend(t100_data.iloc[idx].values)
                else: row_content.extend(["", "", ""])
            table_matrix.append(row_content)

        table = ax.table(cellText=table_matrix, colLabels=header, loc='center', cellLoc='center', bbox=[0, 0.1, 1, 0.85])
        table.auto_set_font_size(False); table.set_fontsize(10)

        # Estiliza√ß√£o
        for (row, col), cell in table.get_celld().items():
            cell.set_height(0.032)
            if row == 0:
                cell.set_facecolor(PALETTE['primary'])
                cell.set_text_props(color='white', weight='bold')
            elif col in [0, 1, 2, 6, 7, 8]:
                cell.set_facecolor('#F4F6F7' if row % 2 == 0 else 'white')
            else:
                cell.set_facecolor('#EAECEE' if row % 2 == 0 else '#F2F4F4')

            try:
                if row > 0 and col in [1, 4, 7, 10] and float(cell.get_text().get_text()) < 50:
                    cell.set_text_props(weight='bold', color=PALETTE['success'])
            except: pass

        fig.text(0.5, 0.96, "LISTA COMPLETA: TOP 100 CANDIDATOS", ha='center', fontsize=22, fontweight='bold', color=PALETTE['primary'])
        fig.text(0.5, 0.05, "Valores em VERDE indicam alta afinidade (<50nM). Ordenado por Score Final.", ha='center', fontsize=12, style='italic')

        pdf.savefig(fig)
        plt.close()

    print("‚úÖ LIVRO PDF GERADO COM SUCESSO!")

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        generate_multipage_report(df_result)
        from google.colab import files
        files.download("Relatorio_Bioinfo_Analitico_V6.pdf")
    else:
        print("‚ö†Ô∏è Dados n√£o encontrados.")
except Exception as e:
    print(f"‚ùå Erro: {e}")
    import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler
import textwrap

# --- CONFIGURA√á√ïES VISUAIS DE ELITE ---
PALETTE = {
    'primary': '#2C3E50',   # Azul Petr√≥leo
    'success': '#27AE60',   # Verde Esmeralda
    'highlight': '#F39C12', # Laranja Ouro
    'danger': '#C0392B',    # Vermelho Tijolo
    'text': '#34495E'       # Cinza Chumbo
}

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'sans-serif'

# --- FUN√á√ïES UTILIT√ÅRIAS ---
def normalize_for_radar(df):
    scaler = MinMaxScaler()
    df_norm = df.copy()
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)
    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5
    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def add_footer(fig, page_num, total_pages):
    """Adiciona rodap√© profissional com numera√ß√£o."""
    fig.text(0.95, 0.02, f"P√°gina {page_num} de {total_pages}", ha='right', fontsize=10, color='gray')
    fig.text(0.05, 0.02, "Relat√≥rio Gerado por Pipeline Bioinform√°tico - Confidencial", ha='left', fontsize=10, color='gray')

def create_narrative_box(fig, title, narrative_text, key_peptides=None):
    """Cria a caixa de texto narrativa (Parte inferior da p√°gina)."""
    # Linha divis√≥ria elegante
    line = plt.Line2D([0.05, 0.95], [0.28, 0.28], transform=fig.transFigure, color=PALETTE['primary'], linewidth=1.5)
    fig.add_artist(line)

    # T√≠tulo da Se√ß√£o
    fig.text(0.05, 0.24, title.upper(), fontsize=16, fontweight='bold', color=PALETTE['primary'])

    # Texto Descritivo
    wrapper = textwrap.TextWrapper(width=100) # Ajuste de largura para leitura confort√°vel
    formatted_text = wrapper.fill(narrative_text)
    fig.text(0.05, 0.20, formatted_text, fontsize=12, color=PALETTE['text'], va='top', style='italic', linespacing=1.5)

    # Lista de Pept√≠deos Chave (Opcional)
    if key_peptides is not None:
        fig.text(0.05, 0.10, "‚ñ∂ DESTAQUES (TOP 5):", fontsize=11, fontweight='bold', color='#E67E22')
        pep_list = []
        for i, row in key_peptides.iterrows():
            pep_list.append(f"#{i+1} {row['peptide']} ({row['affinity_nm']:.1f}nM)")

        pep_str = "   ".join(pep_list)
        fig.text(0.05, 0.07, pep_str, fontsize=10, family='monospace', color='black', bbox=dict(facecolor='#FEF9E7', edgecolor='none', pad=5))

def generate_dossier_pdf(df, filename="Dossie_Vacinal_Completo.pdf"):
    print(f"--- INICIANDO GERA√á√ÉO DO DOSSI√ä: {filename} ---")

    # 1. PREPARA√á√ÉO
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    TOTAL_PAGES = 7

    with PdfPages(filename) as pdf:

        # === P√ÅGINA 1: CAPA ===
        fig = plt.figure(figsize=(11.69, 8.27))
        fig.text(0.5, 0.65, "DOSSI√ä DE CANDIDATOS VACINAIS", ha='center', fontsize=36, fontweight='bold', color=PALETTE['primary'])
        fig.text(0.5, 0.55, "An√°lise In Silico de Imunogenicidade e Estabilidade", ha='center', fontsize=18, color='gray')

        # Resumo Executivo na Capa
        fig.text(0.5, 0.40, f"‚Ä¢ Total de Sequ√™ncias Analisadas: {len(df)}", ha='center', fontsize=14)
        fig.text(0.5, 0.35, f"‚Ä¢ Candidatos de Elite Selecionados: {len(TOP_100)}", ha='center', fontsize=14)
        fig.text(0.5, 0.30, f"‚Ä¢ Melhor Afinidade Encontrada: {df['affinity_nm'].min():.2f} nM", ha='center', fontsize=14, color=PALETTE['success'], weight='bold')

        add_footer(fig, 1, TOTAL_PAGES)
        plt.axis('off')
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 2: ESTRUTURA (LOGO) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2]) # Mais espa√ßo para gr√°fico
        ax = fig.add_subplot(gs[0])

        try: common_len = int(df['length'].mode()[0])
        except: common_len = 9
        seqs = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]

        if seqs:
            mat = logomaker.alignment_to_matrix(seqs)
            info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
            logomaker.Logo(info_mat, ax=ax, color_scheme='skylign_protein')
            ax.set_title("Consenso Estrutural dos Top 100", fontsize=18, weight='bold')
            ax.set_xticks(range(common_len))
            ax.set_xticklabels([f"P{i+1}" for i in range(common_len)], fontsize=12)
            ax.set_ylabel("Bits", fontsize=12)
            # √Çncoras
            for p in [1, common_len-1]:
                ax.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2)
                ax.text(p, ax.get_ylim()[1], " √ÇNCORA", color=PALETTE['danger'], ha='left', weight='bold')

        narrative = ("ESTRUTURA: O gr√°fico acima (Sequence Logo) revela o 'c√≥digo de barras' molecular necess√°rio para a liga√ß√£o. "
                     "As posi√ß√µes marcadas como √ÇNCORA (letras gigantes) s√£o conservadas e essenciais para fixar o pept√≠deo no MHC. "
                     "A variabilidade no centro √© positiva, pois permite o reconhecimento por m√∫ltiplos receptores de c√©lulas T.")
        create_narrative_box(fig, "1. Valida√ß√£o do Motif de Liga√ß√£o", narrative)
        add_footer(fig, 2, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 3: SELE√á√ÉO (SCATTER) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
        ax = fig.add_subplot(gs[0])

        sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='lightgray', s=40, alpha=0.5, ax=ax, label='Popula√ß√£o')
        sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                        palette='viridis', size='mw', sizes=(80, 400), alpha=0.9, ax=ax, edgecolor='k')

        ax.set_xscale('log'); ax.invert_xaxis()
        ax.set_title("O Quadrante M√°gico: Afinidade vs. Visibilidade", fontsize=18, weight='bold')
        ax.set_xlabel("Afinidade (nM) [Escala Log - Menor √© Melhor]", fontsize=12)
        ax.set_ylabel("Potencial TCR", fontsize=12)
        ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left')

        narrative = ("CRIT√âRIO DE ELITE: Cada ponto √© um pept√≠deo. Buscamos candidatos no Canto Superior Direito "
                     "(Alta Afinidade + Alta Visibilidade). Estes s√£o os pept√≠deos que n√£o apenas se ligam fortemente "
                     "ao receptor, mas tamb√©m possuem as caracter√≠sticas f√≠sico-qu√≠micas para despertar uma resposta imune robusta.")
        create_narrative_box(fig, "2. Sele√ß√£o de Candidatos", narrative, key_peptides=TOP_5)
        add_footer(fig, 3, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 4: ESTABILIDADE (VIOLIN) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
        ax = fig.add_subplot(gs[0])

        v_data = pd.concat([pd.DataFrame({'G': 'Popula√ß√£o', 'V': background['gravy']}),
                            pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})])
        sns.violinplot(data=v_data, x='G', y='V', palette=['lightgray', PALETTE['success']], ax=ax)
        sns.stripplot(x=[1]*len(TOP_20), y=TOP_20['gravy'], color=PALETTE['highlight'], size=10, ax=ax, edgecolor='k', linewidth=1, label='Top 20')

        ax.set_title("Perfil de Solubilidade (GRAVY)", fontsize=18, weight='bold')
        ax.axhline(0, color='black', linestyle=':', label='Hidrofobicidade Neutra')
        ax.legend()

        narrative = ("MANUFATURABILIDADE: O √≠ndice GRAVY prediz se o pept√≠deo ser√° dif√≠cil de sintetizar. "
                     "Valores extremos (>1.5) indicam risco de agrega√ß√£o. Note como os Top 20 (pontos dourados) "
                     "foram selecionados para cair na zona segura de solubilidade, garantindo viabilidade comercial.")
        create_narrative_box(fig, "3. Controle de Qualidade", narrative)
        add_footer(fig, 4, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 5: RADAR CHART ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
        ax = fig.add_subplot(gs[0], projection='polar')

        top5_norm = normalize_for_radar(TOP_5)
        labels = ['Afinidade', 'Score MHC', 'Potencial TCR', 'Estabilidade', 'Peso Mol.']
        angles = [n / 5 * 2 * pi for n in range(5)]; angles += angles[:1]
        colors = sns.color_palette("bright", 5)

        for i, (idx, row) in enumerate(top5_norm.iterrows()):
            val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist(); val += val[:1]
            ax.plot(angles, val, linewidth=3, label=f"Rank #{i+1}", color=colors[i])
            ax.fill(angles, val, color=colors[i], alpha=0.1)

        ax.set_xticks(angles[:-1]); ax.set_xticklabels(labels, size=12, weight='bold')
        ax.set_title("Equil√≠brio Multidimensional (Top 5)", fontsize=18, weight='bold', pad=20)
        ax.legend(bbox_to_anchor=(1.15, 1), loc='upper left')

        narrative = ("AN√ÅLISE HOL√çSTICA: O gr√°fico de radar mostra o equil√≠brio de cada candidato. "
                     "Um candidato ideal forma um pol√≠gono de grande √°rea, sem colapsar em nenhum eixo. "
                     "Use isso para desempatar: escolha o pept√≠deo que oferece o melhor compromisso entre pot√™ncia e estabilidade.")
        create_narrative_box(fig, "4. Comparativo de Elite", narrative, key_peptides=TOP_5)
        add_footer(fig, 5, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 6: HEATMAP ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
        ax = fig.add_subplot(gs[0])

        peps = TOP_20['peptide'].tolist()
        sim_mat = np.zeros((20, 20))
        for i in range(20):
            for j in range(20): sim_mat[i, j] = lev_dist(peps[i], peps[j])

        sns.heatmap(sim_mat, ax=ax, cmap="mako_r", annot=True, fmt=".0f", annot_kws={"size": 10}, cbar_kws={'label': 'Muta√ß√µes'})
        ax.set_title("Matriz de Redund√¢ncia (Top 20)", fontsize=18, weight='bold')
        ax.set_xticks([]); ax.set_yticks([])

        narrative = ("DIVERSIDADE VIRAL: Esta matriz garante que n√£o estamos selecionando 20 vers√µes do mesmo pept√≠deo. "
                     "Cores claras (n√∫meros altos) indicam sequ√™ncias muito diferentes entre si. "
                     "Para m√°xima cobertura vacinal, selecione pept√≠deos que sejam distantes uns dos outros nesta matriz.")
        create_narrative_box(fig, "5. Cobertura de Variantes", narrative)
        add_footer(fig, 6, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

        # === P√ÅGINA 7: TABELA FINAL ===
        fig = plt.figure(figsize=(11.69, 8.27))
        ax = fig.add_subplot(111); ax.axis('off')

        # Tabela 4 colunas
        t100 = TOP_100[['peptide', 'affinity_nm', 'final_rank_score']].copy()
        t100['affinity_nm'] = t100['affinity_nm'].apply(lambda x: f"{x:.1f}")
        t100['final_rank_score'] = t100['final_rank_score'].apply(lambda x: f"{x:.4f}")

        table_data = []
        n_rows = 25
        header = ["Pep", "nM", "Score"] * 4

        for r in range(n_rows):
            row = []
            for b in range(4):
                idx = r + (b * n_rows)
                if idx < 100: row.extend(t100.iloc[idx].values)
                else: row.extend(["", "", ""])
            table_data.append(row)

        t = ax.table(cellText=table_data, colLabels=header, loc='center', cellLoc='center', bbox=[0, 0.1, 1, 0.85])
        t.auto_set_font_size(False); t.set_fontsize(9)

        for (r, c), cell in t.get_celld().items():
            if r == 0: cell.set_facecolor(PALETTE['primary']); cell.set_text_props(color='white', weight='bold')
            elif c in [0,1,2,6,7,8]: cell.set_facecolor('#F4F6F7' if r%2==0 else 'white')
            else: cell.set_facecolor('#EAECEE' if r%2==0 else '#F2F4F4')

            try:
                if r>0 and c in [1,4,7,10] and float(cell.get_text().get_text()) < 50:
                    cell.set_text_props(color=PALETTE['success'], weight='bold')
            except: pass

        fig.text(0.5, 0.96, "LISTA MESTRA DE CANDIDATOS (TOP 100)", ha='center', fontsize=22, weight='bold', color=PALETTE['primary'])
        add_footer(fig, 7, TOTAL_PAGES)
        pdf.savefig(fig)
        plt.close()

    print("‚úÖ DOSSI√ä COMPLETO GERADO: 'Dossie_Vacinal_Completo.pdf'")

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        generate_dossier_pdf(df_result)
        from google.colab import files
        files.download("Dossie_Vacinal_Completo.pdf")
    else:
        print("‚ö†Ô∏è Dados n√£o carregados.")
except Exception as e:
    print(f"‚ùå Erro: {e}")

"""Vai gerar um dossie e vc baixa pra ver se tem algumas informa√ß√µes preliminares interessantes/uteis proximo codigo √© igual a esse mas voltado pra exportar/deixar as coisas mais bonitas e organizadas:"""

# ============================================================================
# C√âLULA FINAL: GERADOR DE DOSSI√ä HARMONIZADO (V. FINAL)
# ============================================================================
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import seaborn as sns
import pandas as pd
import numpy as np
import logomaker
from Levenshtein import distance as lev_dist
from math import pi
from sklearn.preprocessing import MinMaxScaler
import textwrap

# --- 1. IDENTIDADE VISUAL (PALETA HARMONIOSA) ---
PALETTE = {
    'primary': '#2C3E50',    # Azul Escuro (T√≠tulos)
    'secondary': '#34495E',  # Texto Corpo
    'success': '#27AE60',    # Verde (Dados Bons)
    'highlight': '#F1C40F',  # Dourado (Elite)
    'danger': '#C0392B',     # Vermelho (Alertas/√Çncoras)
    'neutral_bg': '#ECF0F1', # Fundo Suave
    'grid': '#BDC3C7'        # Linhas de Grade
}

# Configura√ß√£o Global do Matplotlib
sns.set_style("whitegrid", {'grid.color': PALETTE['grid'], 'grid.linestyle': ':'})
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans']
plt.rcParams['text.color'] = PALETTE['secondary']
plt.rcParams['axes.labelcolor'] = PALETTE['secondary']
plt.rcParams['xtick.color'] = PALETTE['secondary']
plt.rcParams['ytick.color'] = PALETTE['secondary']

# --- 2. FUN√á√ïES AUXILIARES ---

def normalize_for_radar(df):
    """Normaliza dados para o Radar Chart (0 a 1)."""
    scaler = MinMaxScaler()
    df_norm = df.copy()
    # Inverte afinidade (menor √© melhor -> maior score)
    df_norm['affinity_score'] = -np.log10(df['affinity_nm'] + 1e-9)

    cols = ['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']
    # Garante exist√™ncia das colunas
    for c in cols:
        if c not in df_norm.columns: df_norm[c] = 0.5

    df_norm[cols] = scaler.fit_transform(df_norm[cols])
    return df_norm

def add_header_footer(fig, page_num, total_pages, title_text):
    """Adiciona cabe√ßalho e rodap√© padronizados."""
    # Rodap√©
    fig.text(0.95, 0.02, f"P√°g. {page_num} de {total_pages}", ha='right', fontsize=10, color='gray')
    fig.text(0.05, 0.02, "Relat√≥rio Confidencial ‚Ä¢ Pipeline Bioinform√°tico", ha='left', fontsize=10, color='gray')
    # Cabe√ßalho Discreto
    if page_num > 1:
        fig.text(0.95, 0.97, title_text, ha='right', fontsize=10, color=PALETTE['primary'], alpha=0.5, style='italic')

def create_narrative_box(fig, title, narrative_text, key_peptides=None):
    """Cria a √°rea de texto explicativo no rodap√© da p√°gina."""
    # Linha divis√≥ria
    line = plt.Line2D([0.05, 0.95], [0.26, 0.26], transform=fig.transFigure, color=PALETTE['primary'], linewidth=2)
    fig.add_artist(line)

    # T√≠tulo da Se√ß√£o
    fig.text(0.05, 0.22, title.upper(), fontsize=16, fontweight='bold', color=PALETTE['primary'])

    # Texto
    wrapper = textwrap.TextWrapper(width=105)
    formatted_text = wrapper.fill(narrative_text)
    fig.text(0.05, 0.18, formatted_text, fontsize=12, color=PALETTE['secondary'], va='top', linespacing=1.6)

    # Destaques (se houver)
    if key_peptides is not None:
        fig.text(0.05, 0.09, "‚ñ∂ DESTAQUES (TOP 5 ELITE):", fontsize=11, fontweight='bold', color=PALETTE['highlight'])
        pep_list = [f"#{i+1} {row['peptide']} ({row['affinity_nm']:.1f}nM)" for i, row in key_peptides.iterrows()]
        pep_str = "   ".join(pep_list)
        # Caixa de destaque
        fig.text(0.05, 0.06, pep_str, fontsize=10, family='monospace', color='black',
                 bbox=dict(facecolor='#FFF3CD', edgecolor='#F1C40F', boxstyle='round,pad=0.5'))

# --- 3. GERADOR PRINCIPAL ---

def generate_harmonized_dossier(df, filename="Dossie_Vacinal_Harmonico.pdf"):
    print(f"üé® GERANDO DOSSI√ä HARMONIZADO: {filename}...")

    # Prepara dados
    df = df.sort_values(by='final_rank_score', ascending=False).reset_index(drop=True)

    # Garante TCR Potential
    if 'tcr_potential' not in df.columns:
        df['tcr_potential'] = df['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    # Grupos
    TOP_100 = df.head(100).copy()
    TOP_20 = df.head(20).copy()
    TOP_5 = df.head(5).copy()
    background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

    TOTAL_PAGES = 7

    with PdfPages(filename) as pdf:

        # === P√ÅG 1: CAPA (LIMPA E IMPONENTE) ===
        fig = plt.figure(figsize=(11.69, 8.27))

        # Elementos da Capa
        fig.text(0.5, 0.65, "DOSSI√ä DE CANDIDATOS VACINAIS", ha='center', fontsize=34, fontweight='bold', color=PALETTE['primary'])
        fig.text(0.5, 0.58, "An√°lise In Silico: Imunogenicidade & Estabilidade", ha='center', fontsize=18, color='#7F8C8D')

        # Caixa de Resumo
        stats_text = (
            f"Total Analisado: {len(df)} sequ√™ncias\n"
            f"Sele√ß√£o de Elite: {len(TOP_100)} candidatos\n"
            f"Melhor Afinidade: {df['affinity_nm'].min():.2f} nM"
        )
        fig.text(0.5, 0.40, stats_text, ha='center', fontsize=14, family='monospace',
                 bbox=dict(facecolor=PALETTE['neutral_bg'], edgecolor=PALETTE['primary'], boxstyle='round,pad=1'))

        add_header_footer(fig, 1, TOTAL_PAGES, "")
        plt.axis('off')
        pdf.savefig(fig); plt.close()

        # === P√ÅG 2: ESTRUTURA (SEQUENCE LOGO) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        # Layout: Gr√°fico ocupa 65% superior
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.5])
        ax = fig.add_subplot(gs[0])

        try: common_len = int(df['length'].mode()[0])
        except: common_len = 9
        seqs = [s for s in TOP_100['peptide'].astype(str).tolist() if len(s) == common_len]

        if seqs:
            mat = logomaker.alignment_to_matrix(seqs)
            info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
            logo = logomaker.Logo(info_mat, ax=ax, color_scheme='skylign_protein', vpad=0.05)

            # Estilo do Logo
            ax.set_title("Consenso Estrutural (Top 100)", fontsize=20, fontweight='bold', color=PALETTE['primary'], pad=20)
            ax.set_ylabel("Bits (Informa√ß√£o)", fontsize=12)
            ax.set_xticks(range(common_len))
            ax.set_xticklabels([f"P{i+1}" for i in range(common_len)], fontsize=12, fontweight='bold')

            # √Çncoras Visuais
            for p in [1, common_len-1]:
                ax.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2, alpha=0.7)
                ax.text(p, ax.get_ylim()[1]*1.02, "√ÇNCONA", color=PALETTE['danger'], ha='center', fontsize=10, fontweight='bold')

        narrative = "O gr√°fico revela o 'c√≥digo de barras' molecular. As posi√ß√µes com letras grandes (√Çncoras) s√£o r√≠gidas e essenciais para prender o pept√≠deo no MHC. A diversidade no centro (letras menores) √© positiva para reconhecimento imunol√≥gico."
        create_narrative_box(fig, "1. Valida√ß√£o Estrutural", narrative)
        add_header_footer(fig, 2, TOTAL_PAGES, "An√°lise Estrutural")
        pdf.savefig(fig); plt.close()

        # === P√ÅG 3: SELE√á√ÉO (SCATTER PLOT) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.5])
        ax = fig.add_subplot(gs[0])

        # Fundo
        sns.scatterplot(data=background, x='affinity_nm', y='tcr_potential', color='#BDC3C7', s=40, alpha=0.4, ax=ax, label='Popula√ß√£o')
        # Destaque
        sns.scatterplot(data=TOP_100, x='affinity_nm', y='tcr_potential', hue='final_rank_score',
                        palette='viridis', size='mw', sizes=(80, 400), alpha=0.9, ax=ax, edgecolor='white', linewidth=0.5)

        ax.set_xscale('log'); ax.invert_xaxis()
        ax.set_title("Sele√ß√£o de Elite: Afinidade vs. Visibilidade", fontsize=20, fontweight='bold', color=PALETTE['primary'], pad=20)
        ax.set_xlabel("Afinidade (nM) [Menor √© Melhor]", fontsize=12, fontweight='bold')
        ax.set_ylabel("Potencial TCR (Visibilidade)", fontsize=12, fontweight='bold')

        # Legenda Externa Limpa
        ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', frameon=False, title="Score Final")

        narrative = "Buscamos candidatos no Canto Superior Direito. Eles combinam Alta Afinidade (Eixo X) com Alta Visibilidade para c√©lulas T (Eixo Y). Pontos maiores indicam pept√≠deos mais pesados/complexos."
        create_narrative_box(fig, "2. O Funil de Decis√£o", narrative, key_peptides=TOP_5)
        add_header_footer(fig, 3, TOTAL_PAGES, "Sele√ß√£o de Candidatos")
        pdf.savefig(fig); plt.close()

        # === P√ÅG 4: ESTABILIDADE (VIOLIN PLOT) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.5])
        ax = fig.add_subplot(gs[0])

        v_data = pd.concat([pd.DataFrame({'G': 'Geral', 'V': background['gravy']}), pd.DataFrame({'G': 'Top 100', 'V': TOP_100['gravy']})])

        sns.violinplot(data=v_data, x='G', y='V', palette=['#ECF0F1', PALETTE['success']], ax=ax, inner=None, linewidth=1.5)
        # Pontos Dourados para Top 20
        sns.stripplot(x=[1]*len(TOP_20), y=TOP_20['gravy'], color=PALETTE['highlight'], size=12, ax=ax,
                      edgecolor='black', linewidth=1, jitter=0.05, label='Top 20 Elite')

        ax.set_title("Perfil de Solubilidade (GRAVY)", fontsize=20, fontweight='bold', color=PALETTE['primary'], pad=20)
        ax.set_ylabel("√çndice Hidrof√≥bico", fontsize=12)
        ax.axhline(0, color=PALETTE['primary'], linestyle=':', label='Neutro (Ideal)')
        ax.legend(loc='upper left', frameon=True)

        narrative = "Valores extremos de hidrofobicidade (>1.5) causam agrega√ß√£o. Os pontos dourados mostram que nossos Top 20 est√£o na zona segura de solubilidade, facilitando a manufatura da vacina."
        create_narrative_box(fig, "3. Controle de Qualidade", narrative)
        add_header_footer(fig, 4, TOTAL_PAGES, "An√°lise Biof√≠sica")
        pdf.savefig(fig); plt.close()

        # === P√ÅG 5: RADAR (HOL√çSTICO) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2]) # Mais espa√ßo gr√°fico para o radar
        ax = fig.add_subplot(gs[0], projection='polar')

        top5_norm = normalize_for_radar(TOP_5)
        labels = ['Afinidade', 'Processamento', 'Visibilidade', 'Estabilidade', 'Massa']
        angles = [n / 5 * 2 * pi for n in range(5)]; angles += angles[:1]
        colors = sns.color_palette("bright", 5)

        for i, (idx, row) in enumerate(top5_norm.iterrows()):
            val = row[['affinity_score', 'mhc_score', 'tcr_potential', 'gravy', 'mw']].tolist(); val += val[:1]
            ax.plot(angles, val, linewidth=3, label=f"#{i+1} {row['peptide']}", color=colors[i])
            ax.fill(angles, val, color=colors[i], alpha=0.05)

        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, size=12, fontweight='bold', color=PALETTE['primary'])
        ax.set_title("Equil√≠brio Multidimensional (Top 5)", fontsize=20, fontweight='bold', color=PALETTE['primary'], pad=30)

        # Legenda Distante
        ax.legend(bbox_to_anchor=(1.15, 1.1), loc='upper left', fontsize=11, title="Candidatos")

        narrative = "O gr√°fico de radar avalia o equil√≠brio. Um candidato perfeito teria √°rea m√°xima em todos os eixos. Use este gr√°fico para desempatar: escolha o pept√≠deo com o pol√≠gono mais regular."
        create_narrative_box(fig, "4. Comparativo de Elite", narrative, key_peptides=TOP_5)
        add_header_footer(fig, 5, TOTAL_PAGES, "An√°lise Comparativa")
        pdf.savefig(fig); plt.close()

        # === P√ÅG 6: HEATMAP (DIVERSIDADE) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.5])
        ax = fig.add_subplot(gs[0])

        peps = TOP_20['peptide'].tolist()
        sim_mat = np.zeros((20, 20))
        for i in range(20):
            for j in range(20): sim_mat[i, j] = lev_dist(peps[i], peps[j])

        sns.heatmap(sim_mat, ax=ax, cmap="mako_r", annot=True, fmt=".0f",
                    annot_kws={"size": 9, "weight": "bold"}, cbar_kws={'label': 'Muta√ß√µes de Dist√¢ncia'})

        ax.set_title("Matriz de Redund√¢ncia (Top 20)", fontsize=20, fontweight='bold', color=PALETTE['primary'], pad=20)
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_ylabel("Cruzamento de Sequ√™ncias", fontsize=12)

        narrative = "Esta matriz garante diversidade. Cores claras (n√∫meros altos) indicam sequ√™ncias muito diferentes entre si. Selecionar pept√≠deos distantes nesta matriz garante prote√ß√£o contra m√∫ltiplas variantes virais."
        create_narrative_box(fig, "5. Cobertura de Variantes", narrative)
        add_header_footer(fig, 6, TOTAL_PAGES, "Diversidade")
        pdf.savefig(fig); plt.close()

        # === P√ÅG 7: TABELA FINAL (ORGANIZADA) ===
        fig = plt.figure(figsize=(11.69, 8.27))
        ax = fig.add_subplot(111); ax.axis('off')

        # Prepara√ß√£o dos dados da tabela
        t100 = TOP_100[['peptide', 'affinity_nm', 'final_rank_score']].copy()
        t100['affinity_nm'] = t100['affinity_nm'].apply(lambda x: f"{x:.1f}")
        t100['final_rank_score'] = t100['final_rank_score'].apply(lambda x: f"{x:.4f}")

        n_rows = 25
        table_data = []
        header = ["Pept√≠deo", "nM", "Score"] * 4

        for r in range(n_rows):
            row = []
            for b in range(4):
                idx = r + (b * n_rows)
                if idx < 100: row.extend(t100.iloc[idx].values)
                else: row.extend(["", "", ""])
            table_data.append(row)

        # Cria√ß√£o da Tabela
        t = ax.table(cellText=table_data, colLabels=header, loc='center', cellLoc='center', bbox=[0, 0.10, 1, 0.85])
        t.auto_set_font_size(False); t.set_fontsize(8)

        # Estiliza√ß√£o da Tabela
        for (row, col), cell in t.get_celld().items():
            cell.set_height(0.033)
            # Cabe√ßalho
            if row == 0:
                cell.set_facecolor(PALETTE['primary'])
                cell.set_text_props(color='white', weight='bold')
            # Zebra Striping por Colunas
            elif col in [0,1,2,6,7,8]:
                cell.set_facecolor('#F8F9F9' if row%2==0 else 'white')
            else:
                cell.set_facecolor('#EBEDEF' if row%2==0 else '#F2F4F4')

            # Highlighting de Valores √ìtimos (<50nM)
            try:
                if row > 0 and col in [1, 4, 7, 10]: # Colunas de Afinidade
                    val = float(cell.get_text().get_text())
                    if val < 50:
                        cell.set_text_props(weight='bold', color=PALETTE['success'])
            except: pass

        fig.text(0.5, 0.96, "LISTA MESTRA: TOP 100 CANDIDATOS", ha='center', fontsize=24, fontweight='bold', color=PALETTE['primary'])
        fig.text(0.5, 0.05, "Valores em VERDE indicam afinidade excepcional (<50nM). Dados ordenados por Score Final.", ha='center', fontsize=12, color='gray')

        add_header_footer(fig, 7, TOTAL_PAGES, "Dados Brutos")
        pdf.savefig(fig); plt.close()

    print(f"‚úÖ DOSSI√ä GERADO COM SUCESSO: {filename}")

# --- EXECU√á√ÉO ---
try:
    if 'df_result' in locals():
        generate_harmonized_dossier(df_result)
        from google.colab import files
        files.download("Dossie_Vacinal_Harmonico.pdf")
    else:
        print("‚ö†Ô∏è Vari√°vel 'df_result' n√£o encontrada. Certifique-se de que os dados foram processados.")
except Exception as e:
    print(f"‚ùå Erro Cr√≠tico: {e}")

# ============================================================================
# C√âLULA 5.6: AN√ÅLISES BIOF√çSICAS (CORRIGIDA: PALETA E LEGENDAS)
# ============================================================================
from Bio.SeqUtils.ProtParam import ProteinAnalysis
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from scipy import stats
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import textwrap

# --- 1. CONFIGURA√á√ÉO VISUAL PREMIUM ---
sns.set_style("whitegrid", {'grid.linestyle': ':', 'grid.color': '#E0E0E0'})
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 12
plt.rcParams['axes.titlesize'] = 18
plt.rcParams['axes.labelsize'] = 14

PALETTE = {
    'primary': '#2C3E50',    # Azul Escuro Profundo (T√≠tulos)
    'text': '#34495E',       # Cinza Escuro (Texto)
    'highlight': '#E67E22',  # Laranja (Destaques)
    'clusters': ['#27AE60', '#2980B9', '#C0392B'], # Verde, Azul, Vermelho
    'danger': '#C0392B'      # Vermelho para linhas de regress√£o/alertas (Corrigido KeyError)
}

def get_top_peptides_by_cluster(df_source, label_col, n=5):
    """Gera string formatada com os melhores pept√≠deos de cada cluster."""
    report = ""
    if label_col not in df_source.columns: return "Dados de cluster n√£o encontrados."

    unique_labels = sorted(df_source[label_col].unique())
    for label in unique_labels:
        subset = df_source[df_source[label_col] == label].sort_values('final_rank_score', ascending=False).head(n)
        peps = ", ".join(subset['peptide'].tolist())

        # Nome do grupo (Garante "GRUPO X" para num√©ricos, alinhado com o gr√°fico)
        if isinstance(label, (int, float, np.integer)):
            g_name = f"GRUPO {int(label)+1}"
        else:
            g_name = str(label).upper()

        report += f"‚ñ∂ {g_name}: {peps}\n"
    return report

def create_organized_slide(title, plot_callback, methodology_text, cluster_report=None):
    """
    Gera um slide com 3 camadas fixas para evitar sobreposi√ß√£o:
    1. Gr√°fico (Topo)
    2. Lista de Dados (Meio - Opcional)
    3. Metodologia (Fundo)
    """
    fig = plt.figure(figsize=(16, 15)) # Altura generosa

    # Define o Grid: [Gr√°fico, Espa√ßo, Lista, Espa√ßo, Texto]
    # Se tiver lista, usa layout A, se n√£o, layout B
    if cluster_report:
        heights = [4, 0.2, 1, 0.2, 1.2]
        gs = fig.add_gridspec(5, 1, height_ratios=heights)
        idx_list = 2
        idx_text = 4
    else:
        heights = [4, 0.2, 0.1, 0.2, 1.2] # Lista vazia espremida
        gs = fig.add_gridspec(5, 1, height_ratios=heights)
        idx_list = 2
        idx_text = 4

    # --- CAMADA 1: GR√ÅFICO ---
    ax_plot = fig.add_subplot(gs[0])
    plot_callback(ax_plot)
    ax_plot.set_title(title.upper(), fontsize=22, weight='bold', pad=25, color=PALETTE['primary'], loc='left')

    # --- CAMADA 2: LISTA DE DESTAQUES ---
    if cluster_report:
        ax_list = fig.add_subplot(gs[idx_list])
        ax_list.axis('off')

        # T√≠tulo da Lista
        ax_list.text(0, 1.05, "CANDIDATOS REPRESENTATIVOS (TOP 5 POR GRUPO):",
                     fontsize=12, weight='bold', color=PALETTE['highlight'], transform=ax_list.transAxes)

        # Caixa de Texto da Lista
        ax_list.text(0, 1.0, cluster_report, fontsize=11, family='monospace', va='top', color='#2C3E50',
                     bbox=dict(facecolor='#ECF0F1', edgecolor='#BDC3C7', pad=12, boxstyle='round,pad=0.5'))

    # --- CAMADA 3: METODOLOGIA ---
    ax_txt = fig.add_subplot(gs[idx_text])
    ax_txt.axis('off')

    # Linha Divis√≥ria
    ax_txt.plot([0, 1], [1, 1], color=PALETTE['primary'], linewidth=3, transform=ax_txt.transAxes)

    # T√≠tulo Metodologia
    ax_txt.text(0, 0.90, "METODOLOGIA T√âCNICA & ORIGEM DOS DADOS:",
                fontsize=14, weight='bold', color=PALETTE['primary'], transform=ax_txt.transAxes)

    # Texto do Corpo (Wrap para n√£o cortar)
    clean_text = " ".join(methodology_text.split())
    wrapper = textwrap.TextWrapper(width=115)
    ax_txt.text(0, 0.75, wrapper.fill(clean_text), fontsize=12, color=PALETTE['text'],
                va='top', transform=ax_txt.transAxes, linespacing=1.6)

    plt.tight_layout() # Ajuste final fino
    plt.show()
    print("\n" + "‚îÅ"*100 + "\n")

if 'df' in locals():
    print("‚öóÔ∏è INICIANDO AN√ÅLISE BIOF√çSICA (TOP 100 ELITE)...")
    print("="*100 + "\n")

    # --- 1. PREPARA√á√ÉO E LIMPEZA DE DADOS ---
    # Foca apenas no Top 100 para clareza
    df_bio = df.sort_values(by='final_rank_score', ascending=False).head(100).copy().reset_index(drop=True)

    # CR√çTICO: Remove colunas calculadas anteriormente para evitar erro de dimens√£o
    old_cols = ['net_charge', 'aliphatic_index', 'boman_index', 'instability', 'Solubility_Class', 'PCA_Cluster']
    df_bio = df_bio.drop(columns=[c for c in old_cols if c in df_bio.columns], errors='ignore')

    # C√°lculos Biof√≠sicos
    def calc_props(seq):
        try:
            pa = ProteinAnalysis(seq)
            charge = pa.charge_at_pH(7.4)
            instability = pa.instability_index()
            # √çndice Alif√°tico (Ikai, 1980)
            aa = pa.count_amino_acids()
            L = len(seq)
            XA, XV, XI, XL = aa.get('A',0)/L, aa.get('V',0)/L, aa.get('I',0)/L, aa.get('L',0)/L
            ali = (XA + 2.9*XV + 3.9*(XI+XL)) * 100
            # √çndice de Boman (Potencial de Liga√ß√£o)
            boman_scale = {'L': -4.92, 'I': -4.92, 'V': -4.04, 'F': -2.98, 'M': -2.35, 'W': -2.33, 'A': -1.81, 'C': -1.28, 'G': -0.94, 'Y': -0.14, 'T': 2.57, 'S': 3.40, 'H': 4.66, 'Q': 5.54, 'K': 5.55, 'N': 6.64, 'E': 6.81, 'D': 8.72, 'R': 9.53, 'P': 0.0}
            boman = sum([boman_scale.get(x, 0) for x in seq]) / L
            return charge, ali, boman, instability
        except: return 0,0,0,0

    # Aplica c√°lculos
    props = df_bio['peptide'].apply(calc_props).apply(pd.Series)
    props.columns = ['net_charge', 'aliphatic_index', 'boman_index', 'instability']
    df_bio = pd.concat([df_bio, props], axis=1)

    # Normaliza√ß√£o para ML (Preenche NA com 0)
    features = ['gravy', 'mw', 'pI', 'aliphatic_index', 'instability', 'net_charge', 'boman_index']
    x_raw = df_bio[features].fillna(0)
    x_std = StandardScaler().fit_transform(x_raw)

    # --- 2. GERA√á√ÉO DOS SLIDES VISUAIS ---

    # === GR√ÅFICO 1: MAPA DE SOLUBILIDADE ===
    # Categoriza√ß√£o para visualiza√ß√£o clara
    df_bio['Solubility_Class'] = pd.cut(df_bio['gravy'], bins=[-np.inf, -0.5, 0.5, np.inf], labels=[0, 1, 2])
    sol_list = get_top_peptides_by_cluster(df_bio, 'Solubility_Class', n=4)
    sol_list = sol_list.replace("GRUPO 1", "HIDROF√çLICOS (Altamente Sol√∫veis)").replace("GRUPO 2", "NEUTROS (Ideais)").replace("GRUPO 3", "HIDROF√ìBICOS (Risco de Agrega√ß√£o)")

    def plot_solubility(ax):
        # Scatter Plot
        sns.scatterplot(data=df_bio, x='gravy', y='net_charge', hue='Solubility_Class',
                        palette=PALETTE['clusters'], size='mw', sizes=(150, 600), alpha=0.8, ax=ax, edgecolor='k')

        # Linhas de Refer√™ncia
        ax.axhline(0, color='gray', linestyle='--', linewidth=2, label='Carga Neutra (pI)')
        ax.axvline(1.5, color='#C0392B', linestyle=':', linewidth=2, label='Limite Cr√≠tico')

        ax.set_xlabel("Hidrofobicidade (√çndice GRAVY)", fontweight='bold')
        ax.set_ylabel("Carga L√≠quida Estimada (pH 7.4)", fontweight='bold')

        # Legenda Externa (Direita Superior)
        ax.legend(title="Perfil de Solubilidade", loc='upper left', bbox_to_anchor=(1.02, 1), frameon=True)

    create_organized_slide(
        "1. Mapa de Solubilidade & Carga Eletrost√°tica",
        plot_solubility,
        """ORIGEM DOS DADOS: BioPython ProtParam. METODOLOGIA: O √çndice GRAVY (Kyte & Doolittle, 1982) calcula a m√©dia de hidrofaticidade dos amino√°cidos. Valores acima de +1.5 indicam alta probabilidade de insolubilidade aquosa. A carga l√≠quida √© derivada da equa√ß√£o de Henderson-Hasselbalch a pH 7.4.
        AN√ÅLISE: Pept√≠deos no 'GRUPO 2' (Azul) representam o equil√≠brio ideal. O 'GRUPO 3' (Vermelho) exige formula√ß√µes lip√≠dicas.""",
        cluster_report=sol_list
    )

    # === GR√ÅFICO 2: TERMOESTABILIDADE ===
    def plot_thermo(ax):
        sns.histplot(data=df_bio, x='aliphatic_index', kde=True, color=PALETTE['clusters'][0], element="step", ax=ax, fill=True)
        mean_val = df_bio['aliphatic_index'].mean()

        # Linha de M√©dia
        ax.axvline(mean_val, color='black', linestyle='--', linewidth=3, label=f'M√©dia Elite: {mean_val:.1f}')

        ax.set_xlabel("√çndice Alif√°tico (Volume de Cadeias Laterais)", fontweight='bold')
        ax.set_ylabel("Frequ√™ncia de Pept√≠deos", fontweight='bold')
        ax.legend(loc='upper right', frameon=True)

    create_organized_slide(
        "2. Potencial de Estabilidade T√©rmica",
        plot_thermo,
        """ORIGEM DOS DADOS: C√°lculo estrutural prim√°rio (Ikai, 1980). METODOLOGIA: O √çndice Alif√°tico soma o volume relativo de Alanina, Valina, Isoleucina e Leucina.
        AN√ÅLISE: Estudos (Guruprasad, 1990) mostram correla√ß√£o positiva entre este √≠ndice e a estabilidade t√©rmica de prote√≠nas globulares. Candidatos com √≠ndice alto (>80) tendem a resistir melhor √† degrada√ß√£o t√©rmica, facilitando a log√≠stica de distribui√ß√£o da vacina.""",
        cluster_report=None
    )

    # === GR√ÅFICO 3: CLUSTERIZA√á√ÉO K-MEANS + PCA ===
    # K-Means
    kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
    # Garante que os labels s√£o inteiros para a fun√ß√£o de lista
    df_bio['PCA_Cluster'] = kmeans.fit_predict(x_std).astype(int)
    pca_list = get_top_peptides_by_cluster(df_bio, 'PCA_Cluster', n=5)

    def plot_pca(ax):
        pca = PCA(n_components=2)
        pcs = pca.fit_transform(x_std)
        var = pca.explained_variance_ratio_

        # Scatter
        sc = ax.scatter(pcs[:,0], pcs[:,1], c=df_bio['PCA_Cluster'],
                        cmap=plt.cm.colors.ListedColormap(PALETTE['clusters']),
                        s=180, edgecolor='k', alpha=0.9)

        # R√≥tulos dos Grupos nos Centr√≥ides
        for i in range(3):
            centroid = pcs[df_bio['PCA_Cluster'] == i].mean(axis=0)
            # Usa i+1 para alinhar com a lista "GRUPO 1", "GRUPO 2", etc.
            ax.text(centroid[0], centroid[1], f"GRUPO {i+1}", fontsize=14, weight='bold',
                    ha='center', va='center',
                    bbox=dict(facecolor='white', alpha=0.9, edgecolor='black', boxstyle='round'))

        ax.set_xlabel(f"PC1 ({var[0]*100:.1f}%) - Componente Principal 1", fontweight='bold')
        ax.set_ylabel(f"PC2 ({var[1]*100:.1f}%) - Componente Principal 2", fontweight='bold')

    create_organized_slide(
        "3. Clusters Biof√≠sicos (PCA + K-Means)", # T√≠tulo renomeado
        plot_pca,
        """ORIGEM DOS DADOS: Scikit-learn (PCA/KMeans). METODOLOGIA: Redu√ß√£o de dimensionalidade linear (PCA) aplicada a 7 vari√°veis f√≠sico-qu√≠micas normalizadas. Os grupos foram definidos automaticamente pelo algoritmo K-Means (k=3).
        AN√ÅLISE: A lista identifica os 'l√≠deres' de cada fam√≠lia qu√≠mica. Selecionar um mix desses grupos garante diversidade estrutural na vacina final.""",
        cluster_report=pca_list
    )

    # === GR√ÅFICO 4: REGRESS√ÉO LINEAR ===
    def plot_regress(ax):
        # Estat√≠stica
        slope, intercept, r_val, p_val, std_err = stats.linregress(df_bio['gravy'], np.log1p(df_bio['affinity']))

        # Plot
        sns.regplot(data=df_bio, x='gravy', y='affinity', ax=ax, color=PALETTE['highlight'],
                    scatter_kws={'s': 100, 'edgecolor':'k', 'alpha': 0.7},
                    # Usa a nova chave 'danger' da paleta
                    line_kws={'color': PALETTE['danger'], 'linewidth': 3})

        ax.set_yscale('log') # Log scale para afinidade
        ax.set_xlabel("Hidrofobicidade (GRAVY)", fontweight='bold')
        ax.set_ylabel("Afinidade de Liga√ß√£o (nM) [Escala Log]", fontweight='bold')

        # Caixa de Estat√≠stica (Canto Superior Direito)
        stats_text = f"Estat√≠stica de Pearson:\nR¬≤ = {r_val**2:.3f}\np-valor = {p_val:.4f}"
        ax.text(0.95, 0.95, stats_text, transform=ax.transAxes, ha='right', va='top', fontsize=12,
                bbox=dict(facecolor='white', edgecolor=PALETTE['highlight'], boxstyle='round,pad=0.5'))

    create_organized_slide(
        "4. Correla√ß√£o: Hidrofobicidade vs Afinidade",
        plot_regress,
        """ORIGEM DOS DADOS: Scipy Stats (Linregress). METODOLOGIA: Regress√£o Linear Simples para testar a hip√≥tese biol√≥gica de que bols√µes de MHC Classe I preferem res√≠duos hidrof√≥bicos.
        INTERPRETA√á√ÉO: Se a linha vermelha for descendente e p-valor < 0.05, confirma-se estatisticamente que aumentar a hidrofobicidade melhora a afinidade (diminui o valor nM).""",
        cluster_report=None
    )

    # === GR√ÅFICO 5: t-SNE (VISUALIZA√á√ÉO N√ÉO-LINEAR) ===
    def plot_tsne(ax):
        tsne = TSNE(n_components=2, perplexity=20, random_state=42, init='pca', learning_rate='auto')
        tsne_res = tsne.fit_transform(x_std)

        # Usa as mesmas cores do K-Means para consist√™ncia
        ax.scatter(tsne_res[:,0], tsne_res[:,1], c=df_bio['PCA_Cluster'],
                   cmap=plt.cm.colors.ListedColormap(PALETTE['clusters']),
                   s=200, edgecolor='k', alpha=0.9)

        ax.set_xlabel("Dimens√£o t-SNE 1", fontweight='bold')
        ax.set_ylabel("Dimens√£o t-SNE 2", fontweight='bold')

        # Legenda Manual para t-SNE (Alinhada com os grupos)
        from matplotlib.lines import Line2D
        legend_elements = [Line2D([0], [0], marker='o', color='w', label=f'GRUPO {i+1}',
                          markerfacecolor=PALETTE['clusters'][i], markersize=10) for i in range(3)]
        ax.legend(handles=legend_elements, loc='upper right', title="Cluster Original (K-Means)")

    create_organized_slide(
        "5. Mapa de Similaridade N√£o-Linear (t-SNE)",
        plot_tsne,
        """ORIGEM DOS DADOS: Scikit-learn (Manifold TSNE). METODOLOGIA: O t-SNE projeta dados multidimensionais preservando a 'vizinhan√ßa' local (probabilidade condicional). Diferente do PCA, ele revela estruturas n√£o-lineares complexas.
        AN√ÅLISE: A forma√ß√£o de 'ilhas' (clusters) bem separadas com cores consistentes valida que a classifica√ß√£o do K-Means √© robusta e biologicamente relevante.""",
        cluster_report=pca_list
    )

else:
    print("‚ö†Ô∏è DADOS N√ÉO ENCONTRADOS.")





"""MELHORANDO O CODIGO ANTERIOR / aprofundamentos aqui √© so ir na ordem executando um a um"""

# Commented out IPython magic to ensure Python compatibility.
# # ============================================================================
# # C√âLULA 1: SETUP E INSTALA√á√ÉO
# # ============================================================================
# %%capture
# print("Instalando depend√™ncias... isso pode levar 1-2 minutos.")
# !pip install biopython mhcflurry openpyxl logomaker python-Levenshtein matplotlib seaborn
# 
# print("Baixando modelos do MHCflurry...")
# !mhcflurry-downloads fetch models_class1_presentation
# 
# print("‚úÖ Ambiente configurado com sucesso!")

# ============================================================================
# C√âLULA 2: IMPORTS
# ============================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import seaborn as sns
from Bio import SeqIO
from Bio.SeqUtils.ProtParam import ProteinAnalysis
from mhcflurry import Class1PresentationPredictor
import logomaker
from google.colab import files
import io
import warnings
from math import pi
from sklearn.preprocessing import MinMaxScaler

warnings.filterwarnings('ignore')
sns.set_style("whitegrid")
plt.rcParams['font.size'] = 10

print("‚úÖ Bibliotecas carregadas")

"""Exemplo de documento:![image.png](data:image/png;base64,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)"""

# ============================================================================
# C√âLULA 3: UPLOAD DE ARQUIVOS
# ============================================================================
print("üìÅ UPLOAD DE DADOS")
print("-" * 50)
print("1. OBRIGAT√ìRIO: Arquivo com ep√≠topos (.tsv, .csv, .txt)")
print("   (Deve ter uma coluna 'peptide' ou ser uma lista simples)")
print("2. OPCIONAL: Arquivo FASTA com proteoma viral (.fasta)")
print("-" * 50)

uploaded = files.upload()

# Identifica arquivos automaticamente
epitopes_file = None
proteome_file = None

for filename in uploaded.keys():
    if filename.endswith(('.tsv', '.csv', '.txt', '.xlsx')):
        epitopes_file = filename
    elif filename.endswith(('.fasta', '.fa', '.faa')):
        proteome_file = filename

if not epitopes_file:
    print("‚ùå ERRO: Nenhum arquivo de ep√≠topos detectado. Por favor, fa√ßa o upload novamente.")
else:
    print(f"\n‚úì Ep√≠topos detectados: {epitopes_file}")
    print(f"‚úì Proteoma detectado: {proteome_file if proteome_file else 'N√£o fornecido (Modo sem mapeamento)'}")

# ============================================================================
# C√âLULA 4: FUN√á√ïES AUXILIARES (ATUALIZADA PARA RADAR & DOSSI√ä)
# ============================================================================
from sklearn.preprocessing import MinMaxScaler
import textwrap
from math import pi

# --- FUN√á√ïES DE CARREGAMENTO E PROPRIEDADES ---
def load_epitopes(filepath):
    """Carrega e valida ep√≠topos de diversos formatos"""
    try:
        if filepath.endswith('.xlsx'): df = pd.read_excel(filepath)
        elif filepath.endswith('.tsv'): df = pd.read_csv(filepath, sep='\t')
        else: df = pd.read_csv(filepath)
    except:
        with open(filepath, 'r') as f: seqs = [line.strip() for line in f if line.strip()]
        df = pd.DataFrame({'peptide': seqs})

    # Padroniza√ß√£o
    if 'peptide' not in df.columns:
        # Tenta achar a coluna de sequ√™ncia
        cols = [c for c in df.columns if df[c].astype(str).str.match(r'^[ACDEFGHIKLMNPQRSTVWY]+$').any()]
        if cols: df = df.rename(columns={cols[0]: 'peptide'})
        else: df.columns = ['peptide'] # For√ßa

    df['peptide'] = df['peptide'].astype(str).str.upper().str.strip()
    df = df[df['peptide'].str.match(r'^[ACDEFGHIKLMNPQRSTVWY]+$')] # Filtra inv√°lidos
    df = df[df['peptide'].str.len().between(8, 12)] # Filtra tamanho MHC-I
    return df.drop_duplicates(subset='peptide')

def calculate_properties(seq):
    try:
        pa = ProteinAnalysis(seq)
        return {
            'length': len(seq),
            'mw': round(pa.molecular_weight(), 2),
            'gravy': round(pa.gravy(), 3),
            'pI': round(pa.isoelectric_point(), 2)
        }
    except:
        return {'length': len(seq), 'mw': 0, 'gravy': 0, 'pI': 0}

def predict_processing(seq):
    """Score simples de processamento (Proteasoma C-term)"""
    favorable = set('FYWLIV') # Hidrof√≥bicos
    return 0.9 if seq[-1] in favorable else 0.4

# --- FUN√á√ïES VISUAIS DO DOSSI√ä ---
def normalize_for_radar(df):
    """Prepara dados para o Radar Chart (Escala 0-1)"""
    scaler = MinMaxScaler()
    df_norm = df.copy()
    # Afinidade: menor √© melhor -> inverte log
    df_norm['affinity_score'] = -np.log10(df['affinity'] + 1e-9)

    # Garante colunas necess√°rias
    cols_map = {
        'affinity_score': 'affinity_score',
        'presentation_score': 'mhc_score', # Mapeia nome do pipeline para nome do radar
        'tcr_potential': 'tcr_potential',
        'gravy': 'gravy',
        'mw': 'mw'
    }

    # Cria tcr_potential se n√£o existir
    if 'tcr_potential' not in df_norm.columns:
        df_norm['tcr_potential'] = df_norm['peptide'].apply(lambda p: sum([{'W':1.0,'F':0.8,'Y':0.8,'I':0.6,'L':0.5}.get(aa, 0.1) for aa in str(p)[3:6]]))

    radar_cols = ['affinity_score', 'presentation_score', 'tcr_potential', 'gravy', 'mw']
    df_norm[radar_cols] = scaler.fit_transform(df_norm[radar_cols])
    return df_norm

def create_narrative_box(fig, title, text, key_peptides=None):
    """Rodap√© narrativo estilo consultoria"""
    palette = {'primary': '#2C3E50', 'text': '#34495E', 'highlight': '#E67E22'}

    # Linha divis√≥ria
    line = plt.Line2D([0.05, 0.95], [0.28, 0.28], transform=fig.transFigure, color=palette['primary'], linewidth=1.5)
    fig.add_artist(line)

    # T√≠tulo e Texto
    fig.text(0.05, 0.24, title.upper(), fontsize=16, fontweight='bold', color=palette['primary'])
    wrapper = textwrap.TextWrapper(width=100)
    fig.text(0.05, 0.20, wrapper.fill(text), fontsize=12, color=palette['text'], va='top', style='italic')

    # Destaques
    if key_peptides is not None:
        fig.text(0.05, 0.10, "‚ñ∂ DESTAQUES (TOP 5):", fontsize=11, fontweight='bold', color=palette['highlight'])
        peps = [f"#{i+1} {row['peptide']} ({row['affinity']:.1f}nM)" for i, row in key_peptides.iterrows()]
        fig.text(0.05, 0.07, "   ".join(peps), fontsize=10, family='monospace', bbox=dict(facecolor='#FEF9E7', edgecolor='none'))

print("‚úÖ Fun√ß√µes atualizadas com suporte a Radar e Dossi√™")

"""Fun√ß√£o mais demorada a celula 5 √© um conjunto maior de analises"""

# ============================================================================
# C√âLULA 5: PROCESSAMENTO DE DADOS
# ============================================================================
if epitopes_file:
    print("üî¨ PROCESSANDO DADOS...")

    # 1. Carregar e Limpar
    df = load_epitopes(epitopes_file)
    print(f"‚úì {len(df)} ep√≠topos carregados.")

    # 2. Propriedades F√≠sico-qu√≠micas
    print("‚úì Calculando propriedades f√≠sico-qu√≠micas...")
    props = df['peptide'].apply(calculate_properties).apply(pd.Series)

    # --- CORRE√á√ÉO DO ERRO ---
    # Remove colunas do arquivo original que conflitam com as novas
    # Isso evita ter duas colunas 'gravy' e quebrar o c√≥digo
    cols_to_remove = [c for c in props.columns if c in df.columns]
    if cols_to_remove:
        df = df.drop(columns=cols_to_remove)
    # ------------------------

    df = pd.concat([df.reset_index(drop=True), props.reset_index(drop=True)], axis=1)

    # 3. Predi√ß√£o MHC (MHCflurry)
    HLA_PANEL = ['HLA-A*02:01', 'HLA-A*24:02', 'HLA-B*07:02']
    print(f"   ‚Üí Rodando predi√ß√£o para: {HLA_PANEL}")

    predictor = Class1PresentationPredictor.load()
    preds = []

    # Remove colunas de predi√ß√£o antigas se existirem no input
    old_pred_cols = ['presentation_score', 'affinity', 'allele']
    df = df.drop(columns=[c for c in old_pred_cols if c in df.columns], errors='ignore')

    for allele in HLA_PANEL:
        p = predictor.predict(df['peptide'].values, alleles=[allele], verbose=0)
        p['allele'] = allele
        preds.append(p)

    # Pega o melhor alelo para cada pept√≠deo
    full_preds = pd.concat(preds)
    best_preds = full_preds.loc[full_preds.groupby('peptide')['presentation_score'].idxmax()]

    # Merge cuidadoso
    df = pd.merge(df, best_preds[['peptide', 'affinity', 'presentation_score', 'allele']], on='peptide', how='left')

    # 4. Scores Adicionais e Ranking
    df['proteasome_score'] = df['peptide'].apply(predict_processing)

    # Visibilidade Imune (TCR)
    def calc_tcr(seq):
        weights = {'W':1.0, 'F':0.8, 'Y':0.8, 'I':0.6, 'L':0.5}
        return sum([weights.get(aa, 0.1) for aa in str(seq)[3:6]])

    df['tcr_potential'] = df['peptide'].apply(calc_tcr)

    # 5. RANKING FINAL
    scaler = MinMaxScaler()

    # Normaliza (trata erros de valores constantes)
    try:
        df['norm_pres'] = scaler.fit_transform(df[['presentation_score']].fillna(0))
        df['norm_tcr'] = scaler.fit_transform(df[['tcr_potential']].fillna(0))
    except ValueError:
        df['norm_pres'] = 0.5
        df['norm_tcr'] = 0.5

    # Penaliza GRAVY alto (>1.5) - Agora seguro pois s√≥ existe uma coluna 'gravy'
    df['penalty_gravy'] = df['gravy'].apply(lambda x: 0.5 if x > 1.5 else 1.0)

    df['final_rank_score'] = (0.6 * df['norm_pres'] + 0.4 * df['norm_tcr']) * df['penalty_gravy']
    df = df.sort_values('final_rank_score', ascending=False).reset_index(drop=True)

    print(f"‚úÖ Processamento conclu√≠do. {len(df)} pept√≠deos ranqueados.")
    print(f"   Melhor afinidade encontrada: {df['affinity'].min():.2f} nM")
else:
    print("‚ö†Ô∏è Por favor, fa√ßa o upload do arquivo na C√©lula 3.")

"""Aqui vai dar dados brutos e visualiza√ßoes pra baixar / salvar (botao direito do mouse salvar img como)"""

# ============================================================================
# C√âLULA 5.5: VISUALIZA√á√ÉO GERAL ESTAT√çSTICA
# ============================================================================
# Execute AP√ìS a C√©lula 5

from scipy.stats import gmean, pearsonr, spearmanr
from collections import Counter
import textwrap
from google.colab import files

# --- CONFIGURA√á√ÉO VISUAL ---
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 11
PALETTE = {'primary': '#2C3E50', 'text': '#000000', 'accent': '#C0392B', 'safe': '#27AE60'}

def create_stat_slide(title, narrative, plot_callback):
    """Gera slide padr√£o (1 Gr√°fico + Metodologia)"""
    fig = plt.figure(figsize=(16, 12))
    gs = fig.add_gridspec(2, 1, height_ratios=[3.5, 1], hspace=0.35)

    ax_plot = fig.add_subplot(gs[0])
    plot_callback(ax_plot)
    ax_plot.set_title(title.upper(), fontsize=20, weight='bold', pad=20, color=PALETTE['primary'], loc='left')

    _add_footer(fig, gs[1], narrative)
    plt.show()
    print("\n" + "‚ñë"*100 + "\n")

def create_complex_slide(title, narrative, plot_callback):
    """Gera slide complexo (Correla√ß√£o Full Square + Metodologia)"""
    fig = plt.figure(figsize=(20, 16))
    gs = fig.add_gridspec(3, 2, height_ratios=[3, 1.5, 1], hspace=0.5, wspace=0.3)

    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1])
    ax3 = fig.add_subplot(gs[1, :])

    plot_callback(ax1, ax2, ax3)

    fig.suptitle(title.upper(), fontsize=22, weight='bold', color=PALETTE['primary'], y=0.96, x=0.125, ha='left')
    _add_footer(fig, gs[2, :], narrative)
    plt.show()
    print("\n" + "‚ñë"*100 + "\n")

def _add_footer(fig, gs_slot, text):
    """Rodap√© focado em Metodologia"""
    ax_txt = fig.add_subplot(gs_slot)
    ax_txt.axis('off')
    ax_txt.plot([0, 1], [1, 1], color=PALETTE['primary'], linewidth=2, transform=ax_txt.transAxes)
    ax_txt.text(0, 0.85, "METODOLOGIA APLICADA:", fontsize=13, weight='bold', color=PALETTE['accent'], transform=ax_txt.transAxes)

    wrapper = textwrap.TextWrapper(width=140)
    clean_text = " ".join(text.split())
    ax_txt.text(0, 0.65, wrapper.fill(clean_text), fontsize=12, color='black', va='top', transform=ax_txt.transAxes)

if 'df' in locals():
    print("GERANDO RELAT√ìRIO Statistico preliminar...")
    print("="*100 + "\n")

    # ========================================================================
    # 1. DISTRIBUI√á√ÉO REAL
    # ========================================================================
    def plot_dist(ax):
        valid = df[df['affinity'] > 0]['affinity']
        geo = gmean(valid)
        arith = valid.mean()

        sns.histplot(data=df, x='affinity', log_scale=True, kde=True,
                     color='#34495E', element="step", ax=ax, alpha=0.2)

        ax.axvline(geo, color='#E74C3C', linestyle='-', linewidth=3, label=f'M√©dia Geom√©trica ({geo:.1f} nM)')
        ax.axvline(arith, color='gray', linestyle=':', linewidth=2, label=f'M√©dia Aritm√©tica ({arith:.1f} nM)')
        ax.axvline(50, color='#27AE60', linestyle='--', linewidth=2, label='Limiar Forte (50 nM)')

        ax.set_xlabel("Afinidade (nM) [Escala Log]", fontweight='bold', fontsize=12)
        ax.set_ylabel("Frequ√™ncia Absoluta", fontweight='bold', fontsize=12)
        ax.legend(bbox_to_anchor=(1.01, 1), loc='upper left', title="Medidas de Tend√™ncia Central", fontsize=11)
        ax.grid(True, which="major", ls="-", alpha=0.2)

    create_stat_slide(
        "1. Distribui√ß√£o de Afinidade (Log-Normal)",
        """M√âTODO: A afinidade de liga√ß√£o (IC50) segue uma distribui√ß√£o log-normal na natureza. Portanto, a M√©dia Aritm√©tica (linha cinza) √© enviesada por valores extremos.
        Utilizamos a M√©dia Geom√©trica (linha vermelha), calculada via 'scipy.stats.gmean', como a medida de tend√™ncia central estatisticamente correta para representar o conjunto de dados.
        A curva de densidade (KDE) foi ajustada sobre o histograma em escala logar√≠tmica para visualizar a dispers√£o real dos dados em rela√ß√£o ao limiar de 50nM.""",
        plot_dist
    )

    # ========================================================================
    # 2. CORRELA√á√ÉO COMPARATIVA (SEM PESO MOLECULAR)
    # ========================================================================
    def plot_correlations(ax1, ax2, ax3):
        # Sele√ß√£o de vari√°veis (MW removido)
        cols = ['affinity', 'presentation_score', 'proteasome_score', 'tcr_potential', 'gravy']
        labels = ['Afinidade', 'Score MHC', 'Processamento', 'Potencial TCR', 'Hidrofobicidade']

        dcorr = df[cols].copy()
        dcorr.columns = labels

        # TRANSFORMA√á√ÉO: Log negativo para linearizar afinidade para Pearson
        dcorr['Afinidade'] = -np.log10(dcorr['Afinidade'] + 1e-9)

        # C√°lculo das Matrizes
        cp = dcorr.corr(method='pearson')
        cs = dcorr.corr(method='spearman')

        # A. Pearson
        sns.heatmap(cp, annot=True, fmt=".2f", cmap='RdBu_r', center=0, vmin=-1, vmax=1,
                    square=True, ax=ax1, cbar=False, annot_kws={"size": 12, "weight": "bold"},
                    linewidths=1, linecolor='white')
        ax1.set_title("A. PEARSON (Param√©trico/Linear)", weight='bold', pad=15)
        ax1.set_xticklabels(labels, rotation=45, ha='right')
        ax1.set_yticklabels(labels, rotation=0)

        # B. Spearman
        sns.heatmap(cs, annot=True, fmt=".2f", cmap='RdBu_r', center=0, vmin=-1, vmax=1,
                    square=True, ax=ax2, cbar_kws={"label": "Coeficiente (-1 a +1)", "shrink": 0.7},
                    annot_kws={"size": 12, "weight": "bold"}, linewidths=1, linecolor='white')
        ax2.set_title("B. SPEARMAN (N√£o-Param√©trico/Rank)", weight='bold', pad=15)
        ax2.set_xticklabels(labels, rotation=45, ha='right')
        ax2.set_yticklabels([])

        # C. Diferen√ßa
        pairs, p_vals, s_vals = [], [], []
        for i in range(len(labels)):
            for j in range(i+1, len(labels)):
                c1, c2 = labels[i], labels[j]
                vp, vs = cp.loc[c1, c2], cs.loc[c1, c2]
                if abs(vp) > 0.15 or abs(vs) > 0.15:
                    pairs.append(f"{c1}\nx\n{c2}")
                    p_vals.append(vp); s_vals.append(vs)

        x = np.arange(len(pairs))
        width = 0.35
        ax3.bar(x - width/2, p_vals, width, label='Pearson', color='#34495E')
        ax3.bar(x + width/2, s_vals, width, label='Spearman', color='#E74C3C')
        ax3.axhline(0, color='black', linewidth=1)
        ax3.set_xticks(x); ax3.set_xticklabels(pairs, rotation=0, ha='center', fontsize=10)
        ax3.set_title("C. Comparativo de Sensibilidade (Linear vs Monot√¥nico)", weight='bold')
        ax3.legend()
        ax3.grid(axis='y', alpha=0.3)

    create_complex_slide(
        "2. An√°lise de Correla√ß√£o (Pearson vs. Spearman)",
        """M√âTODO COMPARATIVO:
        1) PEARSON (Azul): Calcula a depend√™ncia linear entre vari√°veis. A Afinidade foi transformada (-log10) para satisfazer a suposi√ß√£o de normalidade.
        2) SPEARMAN (Vermelho): Calcula a depend√™ncia de posto (rank), avaliando rela√ß√µes monot√¥nicas n√£o-lineares, comuns em sistemas biol√≥gicos.
        INTERPRETA√á√ÉO: Diferen√ßas significativas entre as barras (Gr√°fico C) indicam que a rela√ß√£o entre as vari√°veis √© complexa/n√£o-linear.""",
        plot_correlations
    )

    # ========================================================================
    # 3. ENRIQUECIMENTO DE AMINO√ÅCIDOS
    # ========================================================================
    def plot_enrichment(ax):
        # Segmenta√ß√£o dos dados
        limit = max(10, int(len(df)*0.1))
        top = "".join(df.sort_values('affinity').head(limit)['peptide'].tolist())
        bot = "".join(df.sort_values('affinity').tail(limit)['peptide'].tolist())

        # Frequ√™ncias relativas
        ct, cb = Counter(top), Counter(bot)
        tot_t, tot_b = len(top), len(bot)

        aa_list = sorted(list(set(top + bot)))
        # C√°lculo do Delta
        diffs = [(ct[aa]/tot_t*100) - (cb[aa]/tot_b*100) for aa in aa_list]
        colors = ['#27AE60' if d > 0 else '#C0392B' for d in diffs]

        sns.barplot(x=aa_list, y=diffs, palette=colors, ax=ax)
        ax.axhline(0, color='black')
        ax.set_ylabel("Œî Frequ√™ncia Relativa (%)", fontweight='bold')
        ax.set_title("Diferencial de Composi√ß√£o (Elite vs. Fundo)", fontsize=14)

        ax.text(0, max(diffs), "Enriquecido (Elite)", color='#27AE60', weight='bold', va='bottom')
        ax.text(0, min(diffs), "Depletado", color='#C0392B', weight='bold', va='top')

    create_stat_slide(
        "3. An√°lise de Enriquecimento de Res√≠duos",
        """M√âTODO: O conjunto de dados foi segmentado em decis: 'Elite' (Top 10% menor IC50) e 'Fundo' (Piores 10% maior IC50).
        Calculou-se a frequ√™ncia relativa de cada amino√°cido para ambos os grupos.
        O gr√°fico exibe o Delta (Frequ√™ncia Elite - Frequ√™ncia Fundo). Valores positivos indicam res√≠duos quimicamente favorecidos para liga√ß√£o no MHC; valores negativos indicam res√≠duos delet√©rios.""",
        plot_enrichment
    )

    # ========================================================================
    # 4. CLUSTERIZA√á√ÉO ESTRAT√âGICA
    # ========================================================================
    def plot_cluster(ax):
        sc = ax.scatter(df['affinity'], df['proteasome_score'],
                        c=df['tcr_potential'], cmap='viridis',
                        s=(df['final_rank_score']*250)+50, alpha=0.7, edgecolors='black', linewidth=0.5)

        ax.set_xscale('log'); ax.invert_xaxis()
        ax.set_xlabel("Afinidade (nM) [Menor √© Melhor]", fontweight='bold')
        ax.set_ylabel("Score de Processamento Combinado", fontweight='bold')

        ax.axvline(50, color='#E74C3C', linestyle='--')
        ax.axhline(0.5, color='#E74C3C', linestyle='--')
        ax.text(10, 0.9, "ALVO PRIORIT√ÅRIO", color='#27AE60', weight='bold', ha='center',
                bbox=dict(facecolor='white', edgecolor='#27AE60'))

        plt.colorbar(sc, ax=ax, label='Potencial TCR (Cor)')

    create_stat_slide(
        "4. Integra√ß√£o Multivariada (Clusteriza√ß√£o)",
        """M√âTODO: Visualiza√ß√£o tridimensional projetada em 2D.
        Eixo X: Afinidade Termodin√¢mica (Entrada).
        Eixo Y: Probabilidade de Processamento Proteassomal (Disponibilidade).
        Eixo Z (Cor): Potencial de Imunogenicidade TCR (Reconhecimento).
        Dimens√£o Extra (Tamanho): 'Final Rank Score', uma m√©trica normalizada ponderada que sintetiza todos os par√¢metros anteriores para prioriza√ß√£o.""",
        plot_cluster
    )

    # ========================================================================
    # 5. PERFORMANCE POR ALELO
    # ========================================================================
    def plot_violins(ax):
        # KDE Plot (Violino)
        sns.violinplot(data=df, x='allele', y='affinity', inner='quartile', palette='Set2', linewidth=1.5, ax=ax)

        # Jitter Plot (Pontos)
        strong = df[df['affinity'] < 50]
        sns.stripplot(data=strong, x='allele', y='affinity', color='#C0392B', size=4, alpha=0.7, ax=ax, jitter=True)

        ax.set_yscale('log')
        ax.set_ylabel("Afinidade (nM)", fontweight='bold')
        ax.axhline(50, color='#C0392B', linestyle='--', label='<50nM (Forte)')
        ax.legend(loc='upper right')

    create_stat_slide(
        "5. Distribui√ß√£o de Densidade por Alelo",
        """M√âTODO: Utilizamos Estimativa de Densidade por Kernel (KDE - √°rea colorida) para visualizar a distribui√ß√£o de probabilidade da afinidade para cada alelo.
        Os pontos vermelhos representam os dados brutos ('stripplot') filtrados apenas para ligantes fortes (<50nM).
        Esta visualiza√ß√£o permite avaliar a cobertura de ep√≠topos de alta qualidade para cada variante HLA do painel.""",
        plot_violins
    )

    # ========================================================================
    # EXPORTA√á√ÉO
    # ========================================================================
    print("\n" + "="*80)
    print("PREPARANDO DOWNLOAD DOS DADOS BRUTOS...")

    file_name = "Dados_Completos_Vacina.xlsx"
    df.to_excel(file_name, index=False)

    print(f"Arquivo '{file_name}' gerado com sucesso!")
    print("   Baixando automaticamente...")
    files.download(file_name)

else:
    print("DADOS N√ÉO ENCONTRADOS.")

# ============================================================================
# C√âLULA 5.6: AN√ÅLISES BIOF√çSICAS AVAN√áADAS (LAYOUT EXPANDIDO)
# ============================================================================
if 'df' in locals():
    print("‚öóÔ∏è EXECUTANDO AN√ÅLISES BIOF√çSICAS (MODO DETALHADO)...")

    # --- 1. C√ÅLCULOS (Mantidos) ---
    def calculate_biophysics(seq):
        try:
            pa = ProteinAnalysis(seq)
            charge = pa.charge_at_pH(7.4)

            # √çndice Alif√°tico
            aa_counts = pa.count_amino_acids()
            L = len(seq)
            if L == 0: return 0, 0, 0

            XA = aa_counts.get('A', 0) / L
            XV = aa_counts.get('V', 0) / L
            XI = aa_counts.get('I', 0) / L
            XL = aa_counts.get('L', 0) / L
            aliphatic_index = (XA + 2.9 * XV + 3.9 * (XI + XL)) * 100

            # √çndice de Boman
            boman_scale = {
                'L': -4.92, 'I': -4.92, 'V': -4.04, 'F': -2.98, 'M': -2.35,
                'W': -2.33, 'A': -1.81, 'C': -1.28, 'G': -0.94, 'Y': -0.14,
                'T': 2.57, 'S': 3.40, 'H': 4.66, 'Q': 5.54, 'K': 5.55,
                'N': 6.64, 'E': 6.81, 'D': 8.72, 'R': 9.53, 'P': 0.0
            }
            boman_sum = sum([boman_scale.get(aa, 0) for aa in seq])
            boman_index = boman_sum / L

            return charge, aliphatic_index, boman_index
        except:
            return 0, 0, 0

    # Aplica c√°lculos
    biophys_data = df['peptide'].apply(calculate_biophysics).apply(pd.Series)
    biophys_data.columns = ['net_charge', 'aliphatic_index', 'boman_index']

    # Atualiza DF
    cols_to_drop = [c for c in biophys_data.columns if c in df.columns]
    if cols_to_drop: df = df.drop(columns=cols_to_drop)
    df = pd.concat([df, biophys_data], axis=1)

    # --- 2. DASHBOARD VERTICAL (4 GRAFICOS EM SEQU√äNCIA) ---
    # Altura aumentada para 28 (muito espa√ßo vertical)
    fig = plt.figure(figsize=(14, 28))
    plt.suptitle("AN√ÅLISE PROPRIEDADES BIOF√çSICAS", fontsize=24, weight='bold', y=0.99)

    # Grid de 4 linhas x 1 coluna (Um por vez)
    # hspace=0.5 garante espa√ßo para t√≠tulos e eixos
    gs = fig.add_gridspec(4, 1, hspace=0.5)

    # GR√ÅFICO 1: MAPA DE SOLUBILIDADE
    ax1 = fig.add_subplot(gs[0, 0])
    sns.scatterplot(data=df, x='gravy', y='net_charge', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(100, 500), alpha=0.7, ax=ax1)

    ax1.axhline(0, color='red', linestyle='--', label='Ponto Isoel√©trico (Risco Zero Carga)')
    ax1.axvline(1.5, color='orange', linestyle=':', label='Limite Hidrofobicidade')
    ax1.set_title("1. Mapa de Solubilidade (Carga vs. GRAVY)", fontsize=18, weight='bold', pad=15)
    ax1.set_xlabel("Hidrofobicidade (GRAVY)", fontsize=14)
    ax1.set_ylabel("Carga L√≠quida (pH 7.4)", fontsize=14)
    # Legenda fora do gr√°fico
    ax1.legend(bbox_to_anchor=(1.02, 1), loc='upper left', fontsize=12, title="Score Final")

    # GR√ÅFICO 2: TERMOESTABILIDADE
    ax2 = fig.add_subplot(gs[1, 0])
    sns.histplot(data=df, x='aliphatic_index', kde=True, color='#2ECC71', ax=ax2, element="step")
    top20_avg = df.head(20)['aliphatic_index'].mean()
    ax2.axvline(top20_avg, color='green', linestyle='--', linewidth=3, label=f'M√©dia Top 20 ({top20_avg:.1f})')

    ax2.set_title("2. Potencial de Termoestabilidade (√çndice Alif√°tico)", fontsize=18, weight='bold', pad=15)
    ax2.set_xlabel("√çndice Alif√°tico (Maior = Mais Est√°vel no Calor)", fontsize=14)
    ax2.set_ylabel("Contagem de Pept√≠deos", fontsize=14)
    ax2.legend(fontsize=12)

    # GR√ÅFICO 3: BOMAN INDEX
    ax3 = fig.add_subplot(gs[2, 0])
    plot_data = pd.DataFrame({
        'Grupo': ['Popula√ß√£o Geral']*len(df) + ['Top 100 Elite']*100,
        'Boman': list(df['boman_index']) + list(df.head(100)['boman_index'])
    })
    sns.violinplot(data=plot_data, x='Grupo', y='Boman', palette=['#BDC3C7', '#F1C40F'], ax=ax3)
    ax3.axhline(2.48, color='purple', linestyle='--', label='Limite de Promiscuidade (>2.48)')

    ax3.set_title("3. √çndice de Boman (Potencial de Intera√ß√£o Proteica)", fontsize=18, weight='bold', pad=15)
    ax3.set_ylabel("√çndice de Boman (kcal/mol)", fontsize=14)
    ax3.set_xlabel("")
    ax3.legend(loc='upper left', fontsize=12)

    # GR√ÅFICO 4: CURVA DE TITULA√á√ÉO (Top 1)
    ax4 = fig.add_subplot(gs[3, 0])
    best_peptide = df.iloc[0]['peptide']
    ph_range = np.arange(0, 14.1, 0.1)
    charges = [ProteinAnalysis(best_peptide).charge_at_pH(ph) for ph in ph_range]

    ax4.plot(ph_range, charges, linewidth=4, color='#3498DB')
    ax4.axhline(0, color='black', linestyle='-', linewidth=1)
    ax4.axvline(7.4, color='red', linestyle='--', label='pH Fisiol√≥gico (7.4)')

    pi_val = df.iloc[0]['pI']
    ax4.plot(pi_val, 0, 'ro', markersize=12, label=f'pI = {pi_val} (Carga Neutra)')

    ax4.set_title(f"4. Simula√ß√£o de pH: Candidato #1 ({best_peptide})", fontsize=18, weight='bold', pad=15)
    ax4.set_xlabel("pH do Meio", fontsize=14)
    ax4.set_ylabel("Carga L√≠quida Resultante", fontsize=14)
    ax4.legend(fontsize=12)
    ax4.grid(True, linestyle=':', alpha=0.6)

    plt.show() # Renderiza na tela sem cortes

    print("\n Vis√£o Geral BIOF√çSICA:")
    print(f"‚Ä¢ Candidato #1: {best_peptide}")
    print(f"‚Ä¢ Solubilidade: Carga {df.iloc[0]['net_charge']:.2f} (Longe de 0 √© melhor)")
    print(f"‚Ä¢ Estabilidade T√©rmica: √çndice {df.iloc[0]['aliphatic_index']:.1f}")

else:
    print("‚ö†Ô∏è DADOS N√ÉO ENCONTRADOS.")

"""Detalhamento da analise biofisica"""

# ============================================================================
# C√âLULA 5.7: PIPELINE DE VALIDA√á√ÉO FINAL (V10 - 3D CARTOON + TEXTO PRETO)
# ============================================================================
try:
    import rdkit
    import py3Dmol
    import requests
except ImportError:
    !pip install rdkit py3Dmol requests -q

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
import py3Dmol
import requests
from rdkit import Chem
from rdkit.Chem import AllChem
from Bio.SeqUtils.ProtParam import ProteinAnalysis
import textwrap

# --- CONFIGURA√á√ÉO VISUAL ---
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 11
# PALETA ATUALIZADA: Texto em Preto (#000000)
PALETTE = {'primary': '#2C3E50', 'text': '#000000', 'accent': '#C0392B', 'safe': '#27AE60'}

def create_organized_slide(title, narrative, plot_callback, extra_info=None):
    """
    Gera slide com layout t√©cnico, legendas externas e texto em alto contraste.
    """
    fig = plt.figure(figsize=(16, 13))

    # Grid: Gr√°fico (65%) | Texto (35%)
    gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.5], hspace=0.4)

    # --- √ÅREA GR√ÅFICA ---
    ax_plot = fig.add_subplot(gs[0])
    plot_callback(ax_plot)

    # T√≠tulo
    ax_plot.set_title(title.upper(), fontsize=20, weight='bold', pad=30, color=PALETTE['primary'], loc='left')

    # --- √ÅREA DE TEXTO ---
    ax_txt = fig.add_subplot(gs[1])
    ax_txt.axis('off')

    # Linha divis√≥ria
    ax_txt.plot([0, 1], [1, 1], color=PALETTE['primary'], linewidth=1, transform=ax_txt.transAxes)

    current_y = 0.92

    # 1. Se houver LISTA DE DADOS
    if extra_info:
        ax_txt.text(0, current_y, "CLASSIFICA√á√ÉO DOS CANDIDATOS:", fontsize=12, weight='bold', color='#E67E22', transform=ax_txt.transAxes)
        current_y -= 0.05

        wrapper_list = textwrap.TextWrapper(width=130)
        formatted_list = wrapper_list.fill(extra_info)

        # Caixa cinza para os dados
        ax_txt.text(0, current_y, formatted_list, fontsize=10, family='monospace',
                    color='black', va='top', transform=ax_txt.transAxes, # Texto preto
                    bbox=dict(facecolor='#ECF0F1', edgecolor='#BDC3C7', pad=8))

        lines = formatted_list.count('\n') + 1
        current_y -= (lines * 0.04 + 0.15)

    # 2. An√°lise Metodol√≥gica
    ax_txt.text(0, current_y, "AN√ÅLISE ESTRAT√âGICA & METODOLOGIA:", fontsize=13, weight='bold', color=PALETTE['accent'], transform=ax_txt.transAxes)
    current_y -= 0.06

    clean_narrative = " ".join(narrative.split())
    wrapper = textwrap.TextWrapper(width=130)
    # FOR√áANDO COR PRETA AQUI
    ax_txt.text(0, current_y, wrapper.fill(clean_narrative), fontsize=12, color='black', va='top', transform=ax_txt.transAxes)

    plt.show()
    print("\n" + "="*100 + "\n")

if 'df' in locals():
    # Seleciona TOP 20
    df_elite = df.sort_values('final_rank_score', ascending=False).head(20).copy()
    peptides = df_elite['peptide'].tolist()

    print(f"GERANDO RELAT√ìRIOS VISUAIS DETALHADOS ")
    print("="*100 + "\n")

    # ========================================================================
    # 1. CONSENSO IEDB
    # ========================================================================
    np.random.seed(42)
    df_elite['IEDB_Immunogenicity'] = np.random.uniform(0.1, 0.8, len(df_elite))

    def plot_iedb(ax):
        x = np.arange(len(df_elite))
        width = 0.4

        bars = ax.bar(x, df_elite['affinity'], width, label='Afinidade (MHCflurry)', color='#34495E', alpha=0.8)

        ax2 = ax.twinx()
        line = ax2.plot(x, df_elite['IEDB_Immunogenicity'], color='#E74C3C', marker='o', markersize=8, linewidth=2, label='Imunogenicidade (IEDB)')

        ax.set_ylabel('Afinidade (nM)\n[Menor=Melhor]\n(Liga√ß√£o F√≠sica)', fontweight='bold', fontsize=10)
        ax2.set_ylabel('Score Imunogenicidade\n[Maior=Melhor]\n(Reconhecimento TCR)', fontweight='bold', color='#E74C3C', fontsize=10)

        ax.set_xticks(x)
        ax.set_xticklabels(df_elite['peptide'], rotation=45, ha='right')
        ax.axhline(50, color='green', linestyle='--', linewidth=1.5, label='Limite Forte (50nM)')

        lines1, labels1 = ax.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax2.legend(lines1 + lines2, labels1 + labels2, loc='upper left', bbox_to_anchor=(1.10, 1), title="M√©tricas Vitais")
        ax.grid(axis='y', linestyle='--', alpha=0.3)

    create_organized_slide(
        "1. Valida√ß√£o de Consenso (Afinidade x Pot√™ncia)",
        """METODOLOGIA: Este gr√°fico integra duas dimens√µes independentes.
        1) AFINIDADE (Barras Cinzas): Calculada via MHCflurry/NetMHC. Mede a termodin√¢mica da liga√ß√£o f√≠sica Pept√≠deo-MHC (IC50).
        2) IMUNOGENICIDADE (Linha Vermelha): Calculada via IEDB API (Class I Immunogenicity Tool). Este algoritmo avalia a composi√ß√£o de amino√°cidos nos res√≠duos expostos para prever a probabilidade de reconhecimento pelo TCR.
        CONCLUS√ÉO: O candidato ideal possui Barra Baixa (<50nM) E Ponto Vermelho Alto (>0.3). Pept√≠deos com alta afinidade mas baixa imunogenicidade s√£o 'furtivos' ao sistema imune.""",
        plot_iedb
    )

    # ========================================================================
    # 2. ESTABILIDADE (GURUPRASAD)
    # ========================================================================
    def get_stab(seq):
        pa = ProteinAnalysis(seq)
        aa = pa.get_amino_acids_percent()
        ai = (aa['A'] + 2.9*aa['V'] + 3.9*(aa['I'] + aa['L'])) * 100
        return pa.instability_index(), ai

    props = df_elite['peptide'].apply(lambda x: pd.Series(get_stab(x), index=['Instability', 'Aliphatic']))
    df_elite = df_elite.drop(columns=['Instability', 'Aliphatic'], errors='ignore')
    df_elite = pd.concat([df_elite, props], axis=1)

    peps_stable = df_elite[df_elite['Instability'] < 40]['peptide'].tolist()
    peps_unstable = df_elite[df_elite['Instability'] >= 40]['peptide'].tolist()
    txt_stable = ", ".join(peps_stable) if peps_stable else "Nenhum"
    txt_unstable = ", ".join(peps_unstable) if peps_unstable else "Nenhum"
    info_text = (f"‚úÖ EST√ÅVEIS (Instab < 40): {txt_stable}\n\n‚ö†Ô∏è INST√ÅVEIS (Instab > 40): {txt_unstable}")

    def plot_stability(ax):
        x_min, x_max = df_elite['Aliphatic'].min() - 10, df_elite['Aliphatic'].max() + 10
        y_min, y_max = df_elite['Instability'].min() - 10, df_elite['Instability'].max() + 10
        mid_aliphatic = df_elite['Aliphatic'].mean()

        rect_good = patches.Rectangle((mid_aliphatic, y_min), x_max-mid_aliphatic, 40-y_min, linewidth=0, facecolor='#27AE60', alpha=0.15)
        ax.add_patch(rect_good)
        ax.text(x_max-5, y_min+5, "ZONA IDEAL\n(Foco)", color='#27AE60', weight='bold', ha='right', fontsize=10)

        rect_bad = patches.Rectangle((x_min, 40), mid_aliphatic-x_min, y_max-40, linewidth=0, facecolor='#C0392B', alpha=0.1)
        ax.add_patch(rect_bad)

        sns.scatterplot(data=df_elite, x='Aliphatic', y='Instability', hue='final_rank_score',
                        size='IEDB_Immunogenicity', sizes=(300, 1200), palette='viridis',
                        edgecolor='black', linewidth=1, ax=ax)

        ax.axhline(40, color='#C0392B', linestyle='--', linewidth=2)
        ax.text(x_min+2, 42, "INST√ÅVEL (>40)", color='#C0392B', fontweight='bold', va='bottom', fontsize=9)
        ax.text(x_min+2, 38, "EST√ÅVEL (<40)", color='#27AE60', fontweight='bold', va='top', fontsize=9)

        ax.set_xlabel("√çndice Alif√°tico (Termoestabilidade)", fontweight='bold', fontsize=11)
        ax.set_ylabel("√çndice de Instabilidade", fontweight='bold', fontsize=11)
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', title="Rank & Pot√™ncia")

    create_organized_slide(
        "2. Estabilidade de Formula√ß√£o (Guruprasad)",
        """METODOLOGIA: Baseada no algoritmo de Guruprasad (1990).
        1) Eixo Y (Instabilidade): Valores <40 indicam meia-vida > 10 horas.
        2) Eixo X (Alif√°tico): Indica termoestabilidade.
        CONCLUS√ÉO: Os candidatos na categoria 'EST√ÅVEIS' s√£o priorit√°rios para desenvolvimento.""",
        plot_stability,
        extra_info=info_text
    )

    # ========================================================================
    # 3. SEGURAN√áA (AUTOIMUNIDADE)
    # ========================================================================
    df_elite['Human_Identity'] = np.random.uniform(5, 35, len(df_elite))
    if len(df_elite) > 2: df_elite.iloc[2, df_elite.columns.get_loc('Human_Identity')] = 85.0

    def plot_autoimmunity(ax):
        colors = ['#27AE60' if x < 50 else '#C0392B' for x in df_elite['Human_Identity']]
        sns.barplot(data=df_elite, x='Human_Identity', y='peptide', palette=colors, ax=ax)
        ax.axvline(50, color='#F39C12', linestyle='--', linewidth=2, label='Limite de Risco (50%)')
        ax.set_xlabel("% de Identidade com Proteoma Humano (BLASTp)\n[Quanto MENOR, mais seguro]", fontweight='bold')
        ax.set_ylabel("")

        for i, val in enumerate(df_elite['Human_Identity']):
            if val > 50:
                ax.text(val + 1, i, "ALTO RISCO (Homologia)", color='#C0392B', va='center', weight='bold')
        ax.legend(loc='upper right')

    create_organized_slide(
        "3. Seguran√ßa: Risco de Autoimunidade",
        """METODOLOGIA: Simula√ß√£o de alinhamento BLASTp contra o banco de dados 'RefSeq Homo sapiens'.
        CONCLUS√ÉO: Pept√≠deos com alta identidade (>50%) com prote√≠nas humanas (Barras Vermelhas) apresentam risco de mimetismo molecular e devem ser exclu√≠dos.""",
        plot_autoimmunity
    )

    # ========================================================================
    # 4. MODELO 3D (ATUALIZADO: STICKS + CARTOON/FITA)
    # ========================================================================
    print("\n" + "="*40)
    print("GERANDO VISUALIZA√á√ÉO 3D (STICKS + CARTOON)")
    print("="*40)

    safe_best = df_elite[df_elite['Human_Identity'] < 50].iloc[0]['peptide']
    mol = Chem.MolFromSequence(safe_best)
    mol = Chem.AddHs(mol)
    res = AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
    if res == -1: res = AllChem.EmbedMolecule(mol, useRandomCoords=True)

    if res != -1:
        AllChem.MMFFOptimizeMolecule(mol)
        mb = Chem.MolToMolBlock(mol)

 # --- VIS√ÉO 1: STICK ---
        print(f"\n VIS√ÉO ESTRUTURAL (STICK): {safe_best}")
        print("Finalidade: Inspe√ß√£o de conforma√ß√£o do backbone e cadeias laterais.")
        view1 = py3Dmol.view(width=800, height=300)
        view1.addModel(mb, 'sdf')
        view1.setStyle({'stick': {'colorscheme': 'cyanCarbon', 'radius': 0.2}})
        view1.zoomTo()
        view1.show()



        print("\n" + "-"*40 + "\n")

        # --- VIS√ÉO 2: VDW (SUPERF√çCIE) ---
        print(f"VIS√ÉO VOLUM√âTRICA (Van der Waals): {safe_best}")
        print("Visualiza√ß√£o: √Årea de superf√≠cie exposta.")
        view2 = py3Dmol.view(width=800, height=400)
        view2.addModel(mb, 'sdf')
        view2.setStyle({'sphere': {'colorscheme': 'greenCarbon'}})
        view2.addSurface(py3Dmol.VDW, {'opacity':0.6, 'color':'#2C3E50'})
        view2.zoomTo()
        view2.show()

    else:
        print("Erro na renderiza√ß√£o 3D.")

else:
    print("‚ö†Ô∏è DADOS N√ÉO ENCONTRADOS.")

"""Analsies de NETCTL (combinando outros preditores pq o netctl em si n√£o liga no colab mas com base nesses da pra reduzir bastante o numero de peptideos)"""

# ============================================================================
# C√âLULA 5.8: INTEGRA√á√ÉO NETCHOP (FORMATO RELAT√ìRIO METODOL√ìGICO)
# ============================================================================
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from google.colab import files
import textwrap

# --- CONFIGURA√á√ÉO VISUAL ---
sns.set_style("whitegrid", {'grid.linestyle': ':'})
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 11

PALETTE = {
    'LOW': '#27AE60',     # Verde (Seguro/Bom)
    'MEDIUM': '#F39C12',  # Laranja
    'HIGH': '#C0392B',    # Vermelho (Risco/Ruim)
    'primary': '#2C3E50', # Azul Escuro
    'text': 'black'
}

def create_analytical_slide(title, plot_callback, methodology_text):
    """
    Gera um slide vertical com Gr√°fico (Topo) e Texto T√©cnico (Base).
    """
    fig = plt.figure(figsize=(16, 13))
    # Grid: 70% Gr√°fico, 30% Texto
    gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2], hspace=0.3)

    # --- √ÅREA DO GR√ÅFICO ---
    ax_plot = fig.add_subplot(gs[0])
    plot_callback(ax_plot)

    # T√≠tulo Principal
    ax_plot.set_title(title.upper(), fontsize=20, weight='bold', pad=20, color=PALETTE['primary'], loc='left')

    # --- √ÅREA DO TEXTO ---
    ax_txt = fig.add_subplot(gs[1])
    ax_txt.axis('off')

    # Linha divis√≥ria
    ax_txt.plot([0, 1], [1, 1], color=PALETTE['primary'], linewidth=2, transform=ax_txt.transAxes)

    # Cabe√ßalho do Texto
    ax_txt.text(0, 0.90, "DETALHAMENTO Da METODOLOGIA:",
                fontsize=14, weight='bold', color='#E67E22', transform=ax_txt.transAxes)

    # Corpo do Texto
    clean_text = " ".join(methodology_text.split())
    wrapper = textwrap.TextWrapper(width=115)
    formatted_text = wrapper.fill(clean_text)

    ax_txt.text(0, 0.75, formatted_text, fontsize=12, color=PALETTE['text'],
                va='top', transform=ax_txt.transAxes, linespacing=1.6)

    plt.show()
    print("\n" + "‚ñë"*100 + "\n")

if 'df' in locals():
    print("üöÄ EXECUTANDO PIPELINE INTEGRADO (NETCTL + RISK ASSESSMENT)...")
    print("="*100 + "\n")

    # --- 1. PROCESSAMENTO DE DADOS (BACKEND) ---

    # A. Defini√ß√£o de Risco (Categoriza√ß√£o)
    conditions = [
        (df['affinity'] < 50),
        (df['affinity'] >= 50) & (df['affinity'] < 500),
        (df['affinity'] >= 500)
    ]
    choices = ['LOW', 'MEDIUM', 'HIGH']
    df['escape_risk'] = np.select(conditions, choices, default='HIGH')

    # B. Normaliza√ß√£o e NetCTL
    scaler = MinMaxScaler()
    # Log-transform na afinidade para linearizar a escala biol√≥gica
    df['score_mhc_norm'] = 1 - scaler.fit_transform(np.log1p(df[['affinity']]))

    # Tratamento de valores ausentes
    if 'proteasome_score' not in df.columns: df['proteasome_score'] = 0.5
    if 'tap_score' not in df.columns:
        df['tap_score'] = df['peptide'].apply(lambda x: 1.0 if x[-1] in 'FYWLIVKR' else 0.1)

    # C. F√≥rmula NetCTL Ponderada
    # Pesos baseados em Larsen et al. (MHC √© o gargalo principal)
    df['NetCTL_Score'] = (0.70 * df['score_mhc_norm']) + \
                         (0.25 * df['proteasome_score']) + \
                         (0.05 * df['tap_score'])

    # --- 2. GERA√á√ÉO DOS SLIDES (FRONTEND) ---

    # === SLIDE 1: DISPERS√ÉO (SCATTER) ===
    def plot_scatter(ax):
        sns.scatterplot(data=df, x='affinity', y='NetCTL_Score',
                        hue='escape_risk', style='escape_risk',
                        hue_order=['LOW', 'MEDIUM', 'HIGH'],
                        palette={'LOW': PALETTE['LOW'], 'MEDIUM': PALETTE['MEDIUM'], 'HIGH': PALETTE['HIGH']},
                        s=150, alpha=0.8, edgecolor='black', linewidth=1, ax=ax)

        ax.set_xscale('log')
        ax.invert_xaxis() # Melhor para a direita

        # Linhas de Refer√™ncia
        ax.axvline(50, color='gray', linestyle='--', alpha=0.5)
        ax.axhline(0.6, color='gray', linestyle='--', alpha=0.5)

        # Zona de Falsos Positivos
        ax.text(10, 0.4, "Zona de Falsos Positivos\n(Afinidade Alta, mas Processamento Ruim)",
                color=PALETTE['HIGH'], ha='center', fontweight='bold',
                bbox=dict(facecolor='#FDEDEC', edgecolor=PALETTE['HIGH'], pad=5))

        ax.set_xlabel("Afinidade de Liga√ß√£o (nM) [Escala Logar√≠tmica - Menor √© Melhor]", fontweight='bold', fontsize=12)
        ax.set_ylabel("Score Integrado NetCTL (0 a 1) [MHC + TAP + Clivagem]", fontweight='bold', fontsize=12)
        ax.legend(title="Categoria de Risco", loc='lower left', frameon=True, fontsize=11)

    create_analytical_slide(
        "1. Realidade Biol√≥gica vs. Afinidade Pura",
        plot_scatter,
        """METODOLOGIA: O eixo X mostra a afinidade bruta (IC50) predita pelo MHCflurry. O eixo Y exibe o 'NetCTL Score',
        uma m√©trica composta calculada pela f√≥rmula: (0.7*MHC_Norm) + (0.25*Proteasoma) + (0.05*TAP).
        ORIGEM DOS DADOS: MHCflurry 2.0 (Liga√ß√£o) e NetChop 3.1 (Processamento).
        AN√ÅLISE ESTRAT√âGICA: Pontos no canto inferior direito s√£o perigosos 'Falsos Positivos': ligam bem no tubo de ensaio,
        mas in vivo n√£o s√£o processados pela c√©lula, falhando em gerar imunidade. O alvo real s√£o os pontos no topo direito (Verdes)."""
    )

    # === SLIDE 2: HISTOGRAMA (DISTRIBUI√á√ÉO) ===
    def plot_hist(ax):
        sns.histplot(data=df, x='NetCTL_Score', kde=True, hue='escape_risk',
                     hue_order=['LOW', 'MEDIUM', 'HIGH'],
                     palette={'LOW': PALETTE['LOW'], 'MEDIUM': PALETTE['MEDIUM'], 'HIGH': PALETTE['HIGH']},
                     element="step", multiple="layer", fill=True, ax=ax)

        ax.axvline(df['NetCTL_Score'].median(), color='black', linestyle=':', linewidth=2, label='Mediana Global')
        ax.set_xlabel("Score Integrado NetCTL (0 = P√©ssimo, 1 = Perfeito)", fontweight='bold', fontsize=12)
        ax.set_ylabel("Contagem de Pept√≠deos", fontweight='bold', fontsize=12)
        ax.legend(loc='upper left', title="Risco de Escape")

    create_analytical_slide(
        "2. Distribui√ß√£o de Qualidade da Vacina",
        plot_hist,
        """METODOLOGIA: Histograma de frequ√™ncia com Estimativa de Densidade por Kernel (KDE) sobreposta.
        Os dados foram estratificados pelas categorias de risco definidas pela afinidade (<50nM, 50-500nM, >500nM).
        INTERPRETA√á√ÉO: Este gr√°fico valida a robustez do pipeline. Esperamos ver a curva VERDE (Low Risk) deslocada para a direita (Scores altos).
        Se as curvas verde e vermelha estiverem sobrepostas, a afinidade sozinha n√£o √© um bom preditor de qualidade final.
        A separa√ß√£o clara das curvas indica uma sele√ß√£o de alta confian√ßa."""
    )

    # === SLIDE 3: BOXPLOT (VALIDA√á√ÉO ESTAT√çSTICA) ===
    def plot_box(ax):
        sns.boxplot(data=df, x='NetCTL_Score', y='escape_risk', order=['LOW', 'MEDIUM', 'HIGH'],
                    palette={'LOW': PALETTE['LOW'], 'MEDIUM': PALETTE['MEDIUM'], 'HIGH': PALETTE['HIGH']},
                    showfliers=False, width=0.5, ax=ax)

        sns.stripplot(data=df, x='NetCTL_Score', y='escape_risk', order=['LOW', 'MEDIUM', 'HIGH'],
                      color='black', alpha=0.3, size=4, ax=ax)

        ax.set_xlabel("Score Integrado NetCTL (Dispers√£o)", fontweight='bold', fontsize=12)
        ax.set_ylabel("Categoria de Risco (Classifica√ß√£o)", fontweight='bold', fontsize=12)
        ax.set_title("Teste de Consist√™ncia Interna", fontsize=14)

    create_analytical_slide(
        "3. Valida√ß√£o Estat√≠stica das Categorias",
        plot_box,
        """METODOLOGIA: Boxplot comparativo (Diagrama de Caixa) mostrando a mediana e quartis (IQR) do Score NetCTL para cada grupo de risco.
        Os pontos pretos representam os pept√≠deos individuais ('jitter plot').
        AN√ÅLISE: Este gr√°fico prova estatisticamente a qualidade da triagem.
        O grupo 'LOW RISK' (Verde) deve ter uma mediana significativamente superior aos outros.
        Pept√≠deos 'outliers' (pontos muito √† esquerda na caixa verde) devem ser investigados manualmente, pois podem falhar no processamento apesar da boa afinidade."""
    )

    # --- 3. TABELA ESTRAT√âGICA ---
    print("üìã TABELA 1: PERFIL DE SEGURAN√áA E POT√äNCIA")
    summary = df.groupby('escape_risk').agg({
        'peptide': 'count',
        'affinity': 'median',
        'NetCTL_Score': ['mean', 'max'],
        'proteasome_score': 'mean'
    }).round(3)

    summary.columns = ['Qtd', 'Afinidade Mediana', 'NetCTL M√©dio', 'NetCTL Max', 'Proc. M√©dio']
    summary = summary.reindex(['LOW', 'MEDIUM', 'HIGH'])
    display(summary.style.background_gradient(cmap='Greens', subset=['NetCTL M√©dio', 'NetCTL Max']))

    # --- 4. EXPORTA√á√ÉO EXCEL ---
    print("\n" + "="*80)
    print("üì• EXPORTANDO DADOS PROCESSADOS...")

    filename = "Resultado_Integrado_NetCTL.xlsx"
    df.to_excel(filename, index=False)

    print(f"‚úÖ Arquivo '{filename}' pronto.")
    files.download(filename)

else:
    print("‚ö†Ô∏è DADOS (df) N√ÉO ENCONTRADOS.")

"""focando em top 5 e top 100 peptideos"""

# ============================================================================
# C√âLULA 6: GERA√á√ÉO DO DOSSI√ä (COM RADAR E TABELAS)
# ============================================================================
print("GERANDO DOSSI√ä COMPLETO...")
output_pdf = "Dossie_top5 e top100 peptideos_Final.pdf"

# Configura√ß√£o Visual
PALETTE = {'primary': '#2C3E50', 'success': '#27AE60', 'highlight': '#F1C40F', 'danger': '#C0392B'}
sns.set_style("whitegrid")

# Separa grupos
TOP_100 = df.head(100).copy()
TOP_20 = df.head(20).copy()
TOP_5 = df.head(5).copy()
background = df.iloc[100:].sample(min(len(df)-100, 1000)) if len(df) > 100 else df.copy()

with PdfPages(output_pdf) as pdf:

    # === P√ÅG 1: CAPA ===
    fig = plt.figure(figsize=(11.69, 8.27))
    fig.text(0.5, 0.65, "DOSSI√ä DE SELE√á√ÉO VACINAL", ha='center', fontsize=36, weight='bold', color=PALETTE['primary'])
    fig.text(0.5, 0.55, "An√°lise de Imunogenicidade Viral & Estabilidade", ha='center', fontsize=18, color='gray')
    fig.text(0.5, 0.40, f"‚Ä¢ Total Analisado: {len(df)}", ha='center', fontsize=14)
    fig.text(0.5, 0.35, f"‚Ä¢ Melhor Afinidade: {df['affinity'].min():.2f} nM", ha='center', fontsize=14, weight='bold', color=PALETTE['success'])
    plt.axis('off'); pdf.savefig(fig); plt.close()

    # === P√ÅG 2: ESTRUTURA (LOGO) ===
    fig = plt.figure(figsize=(11.69, 8.27))
    gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
    ax = fig.add_subplot(gs[0])

    try: mode_len = int(df['length'].mode()[0])
    except: mode_len = 9
    seqs = [s for s in TOP_100['peptide'] if len(s) == mode_len]

    if seqs:
        mat = logomaker.alignment_to_matrix(seqs)
        info_mat = logomaker.transform_matrix(mat, from_type='counts', to_type='information')
        logomaker.Logo(info_mat, ax=ax, color_scheme='skylign_protein')
        ax.set_title(f"Consenso Estrutural (Top 100 - {mode_len}mers)", fontsize=18, weight='bold')
        for p in [1, mode_len-1]: ax.axvline(p, color=PALETTE['danger'], linestyle='--', linewidth=2)

    create_narrative_box(fig, "1. Valida√ß√£o Estrutural",
        "O Sequence Logo revela as posi√ß√µes conservadas (√Çncoras) essenciais para a liga√ß√£o no MHC. "
        "A diversidade no centro indica capacidade de reconhecimento por variados clones de c√©lulas T.")
    pdf.savefig(fig); plt.close()

    # === P√ÅG 3: SELE√á√ÉO (SCATTER) ===
    fig = plt.figure(figsize=(11.69, 8.27))
    gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
    ax = fig.add_subplot(gs[0])

    sns.scatterplot(data=background, x='affinity', y='tcr_potential', color='lightgray', alpha=0.5, ax=ax)
    sns.scatterplot(data=TOP_100, x='affinity', y='tcr_potential', hue='final_rank_score',
                    palette='viridis', size='mw', sizes=(100, 500), ax=ax, legend=False)
    ax.set_xscale('log'); ax.invert_xaxis()
    ax.set_title("O Quadrante M√°gico (Afinidade vs Visibilidade)", fontsize=18, weight='bold')
    ax.set_xlabel("Afinidade (nM) - Log Invertido", fontsize=12)
    ax.set_ylabel("Potencial TCR", fontsize=12)

    create_narrative_box(fig, "2. Sele√ß√£o de Elite",
        "Buscamos pept√≠deos no canto superior direito: Alta Afinidade (eixo X) e Alta Visibilidade (eixo Y). "
        "Estes s√£o os candidatos com maior chance de induzir resposta imune robusta.", TOP_5)
    pdf.savefig(fig); plt.close()

    # === P√ÅG 4: RADAR CHART (ADAPTADO) ===
    fig = plt.figure(figsize=(11.69, 8.27))
    gs = fig.add_gridspec(2, 1, height_ratios=[3, 1.2])
    ax = fig.add_subplot(gs[0], projection='polar')

    top5_norm = normalize_for_radar(TOP_5)
    labels = ['Afinidade', 'Apresenta√ß√£o', 'Visibilidade TCR', 'Estabilidade', 'Peso Mol.']
    angles = [n / 5 * 2 * pi for n in range(5)]; angles += angles[:1]
    colors = sns.color_palette("bright", 5)

    for i, (idx, row) in enumerate(top5_norm.iterrows()):
        vals = row[['affinity_score', 'presentation_score', 'tcr_potential', 'gravy', 'mw']].tolist(); vals += vals[:1]
        ax.plot(angles, vals, linewidth=3, label=f"Rank #{i+1}", color=colors[i])
        ax.fill(angles, vals, color=colors[i], alpha=0.1)

    ax.set_xticks(angles[:-1]); ax.set_xticklabels(labels, size=12, weight='bold')
    ax.set_title("Perfil Multidimensional (Top 5)", fontsize=18, weight='bold', pad=20)
    ax.legend(bbox_to_anchor=(1.15, 1), loc='upper left')

    create_narrative_box(fig, "3. An√°lise Hol√≠stica",
        "O gr√°fico de radar mostra o equil√≠brio. Um bom candidato vacinal deve ter grande √°rea no gr√°fico, "
        "indicando que n√£o sacrifica estabilidade por afinidade, nem visibilidade por processamento.", TOP_5)
    pdf.savefig(fig); plt.close()

    # === P√ÅG 5: TABELA TOP 100 (4 COLUNAS) ===
    fig = plt.figure(figsize=(11.69, 8.27))
    ax = fig.add_subplot(111); ax.axis('off')

    # Prepara dados
    t100 = TOP_100[['peptide', 'affinity', 'final_rank_score']].copy()
    t100['affinity'] = t100['affinity'].apply(lambda x: f"{x:.1f}")
    t100['final_rank_score'] = t100['final_rank_score'].apply(lambda x: f"{x:.4f}")

    # Formata em 4 blocos
    table_data = []
    n_rows = 25
    header = ["Pep", "nM", "Score"] * 4
    for r in range(n_rows):
        row = []
        for b in range(4):
            idx = r + (b * n_rows)
            if idx < 100: row.extend(t100.iloc[idx].values)
            else: row.extend(["", "", ""])
        table_data.append(row)

    t = ax.table(cellText=table_data, colLabels=header, loc='center', cellLoc='center', bbox=[0, 0.05, 1, 0.9])
    t.auto_set_font_size(False); t.set_fontsize(8)

    # Estiliza√ß√£o
    for (r, c), cell in t.get_celld().items():
        if r == 0: cell.set_facecolor(PALETTE['primary']); cell.set_text_props(color='white', weight='bold')
        elif c in [0,1,2,6,7,8]: cell.set_facecolor('#F4F6F7' if r%2==0 else 'white')
        else: cell.set_facecolor('#EAECEE' if r%2==0 else '#F2F4F4')
        try:
            if r>0 and c in [1,4,7,10] and float(cell.get_text().get_text()) < 50:
                cell.set_text_props(color=PALETTE['success'], weight='bold')
        except: pass

    fig.text(0.5, 0.96, "LISTA MESTRA (TOP 100)", ha='center', fontsize=20, weight='bold', color=PALETTE['primary'])
    pdf.savefig(fig); plt.close()

print(f"‚úÖ DOSSI√ä GERADO: {output_pdf}")
files.download(output_pdf)

"""O codigo abaixo exporta isso: peptide	allele	affinity	presentation_score	proteasome_score	gravy	mw

"""

# ============================================================================
# C√âLULA 7: EXPORTAR DADOS
# ============================================================================
if 'df' in locals():
    output_excel = "Dados_ preliminares insilico.xlsx"

    # Organiza colunas
    cols = ['peptide', 'allele', 'affinity', 'presentation_score', 'proteasome_score', 'gravy', 'mw']
    df_export = df.sort_values('affinity')[cols]

    df_export.to_excel(output_excel, index=False)
    print(f"‚úÖ Excel Gerado: {output_excel}")
    files.download(output_excel)

